# Git様のブランチ

前回のギトギット！ (♪)

0. コミットオブジェクトという言葉を覚えた！
0. コミットオブジェクトの親を辿っていくことで、バージョンの変更記録を列挙できると知った！
0. HEAD はより正確にいえば、作業ディレクトリが元にしているバージョンのことだった！
0. git commit を行うと、元の HEAD を親とする新しいコミットオブジェクトが作られることを知った！
0. git commit を行うと、新しく作られたコミットオブジェクトが HEAD になることを知った！
0. ~~参考文献を読んだ！~~

今回紹介するのは、git の最も強力な機能の1つである **ブランチ**(branch) です。

いくつかのキーポイントをおさえて、ブランチの理解へと達しましょう。

* キーポイント1: ブランチは、コミットオブジェクトにつける名前の一種である。

HEAD がコミットオブジェクトの名前だったことを思い出しますね。
それと似たようなものです。
とはいえ、「一種」と書いたように、名前がすべてブランチなわけではありません。
実際、HEAD はブランチではないです。

* キーポイント2: ブランチに関していろいろなことをするには、git branch コマンドを使う。

ここで、試しにブランチを作ってみましょう。

```
$ git branch ブランチ名 コミットオブジェクト
```

とします。
例えば、

```
$ git branch new_branch HEAD
```

とすれば、new_branch という名前の新しいブランチが作れます。

先ほどのキーポイント1にある通り、new_branch はコミットオブジェクトを指す名前です。
どのコミットオブジェクトかというと、HEAD が表しているコミットオブジェクトです。

```
(あるコミットオブジェクト)
  = HEAD
  = new_branch
```

ブランチの一覧を見るには、git branch コマンドをパラメータなしで使います:

```
$ git branch
* master
  new_branch
```

さらにオプション ``-v`` をつけると、各ブランチが指しているコミットオブジェクトの概要 (ハッシュ値とコミットメッセージの1行目) が分かります:

```
$ git b
* master     3456001 7 回目の更新
  new_branch 3456001 7 回目の更新
```

※ここでは ``b = branch -v`` というエイリアスを使った。

さて、いま作ったブランチ new_branch のほかに、master というブランチがありますね。
これは、リポジトリの最初のコミットオブジェクトを作ったときに、自動的に作られるブランチです。
詳しくは後述しますが、ブランチが1個もない状態はいろいろ不都合なので、自動的に master ブランチが用意されるようになっています。

* キーポイント3: HEADと同じコミットオブジェクトを表すブランチがあるとき、それをカレントブランチという。(やや不正確)

上の git branch の結果に、アスタリスク `*` がありますね。
この印がついたブランチを **カレントブランチ**(current branch) といいます。
重要な概念なので、詳しく解説します。

## カレントブランチ

前回、私はこう述べました。

> HEAD はコミットオブジェクトにつける名前である。

これは事実ですが、まだ理解として不十分なので、再び改めます。

> HEAD はカレントブランチを表すか、あるいはあるコミットオブジェクトを指す名前である。

「あるいは」以降、すなわち「HEAD がカレントブランチを表していない」状態は、カレントブランチが存在しない状態のことです。
この状態にある HEAD を detached HEAD というのですが、実用上、HEAD が detached 状態になるのは一時的なものです。
そのため、

* キーポイント4: HEAD は基本的にカレントブランチを表す。

という認識でよいと思います。

前回、コミットを行うと、HEAD が移動する (新しいコミットオブジェクトを指すようになる) ということをいいました。
このことと (カレントブランチが存在するときは) ``HEAD = カレントブランチ`` のことから、

> (カレントブランチが存在するときに) git commit を行うと、カレントブランチは、その新しいコミットオブジェクトを指すようになる。

ということも分かります。

## HEADの移動
第1部では「HEAD = 最新のコミット」でしたが、HEAD を移動させることで、そうではない状況を作ることができます。

git checkout コマンドを以下のように使うと、カレントブランチを変更し、HEAD を移動させることができます。

```
$ git branch develop HEAD~
$ git checkout develop
Switched to branch 'develop'
```

新しいブランチ develop を作成して、それを checkout しました。
すると、

```
$ git branch -v
* develop    1720f58 6 回目の更新
  master     3456001 7 回目の更新
  new_branch 3456001 7 回目の更新
```

アスタリスク `*` が develop にあるということは、これがカレントブランチであるということです。
また、HEAD は develop = 1720f58 を指すように変化しました。

さらに、この checkout は作業ディレクトリの内容を、 checkout したブランチ (develop) が記録した状態に変更する、という機能もあります。
なので、このとき five.txt は「6 回目の更新」の後の状態になっています。
あ、five.txt とかもう忘れましたよね。
言い直します。
作業ディレクトリはクリーンになっています。

```
$ git status
On branch develop
nothing to commit, working directory clean
```

過去のあるバージョンの作業ディレクトリが簡単に再現できて便利です。

なお、こういう checkout は、作業ディレクトリがクリーンでなく (何らかの変更があり)、その変更を上書きしてしまいそうなときは、何もしません。
「変更を上書きしてしまう事故」を防ぐためだと思います。

## 次回予告
いまのカレントブランチ develop には、「7 回目の更新」が適用されていません。
いわば「古い」状態です。
この状態で、新しいコミットを作ると、「枝分かれ」が発生します。
やってみましょう。

```
$ echo "7 行目？" >> five.txt
$ git commit -a -m "7 回目の更新 (アナザー・ルート)"
```

すると、リポジトリにあるコミットオブジェクトの親子関係は、以下のようになります。

```
3456001 [7 回目の更新] = master
  │
  ↓  ↓─ a8a15f9 [7 回目の更新 (アナザー・ルート)] = develop
1720f58 [6 回目の更新]
  ↓
99bd126 [5 回目の更新]
  ↓
96a691b [4 回目の更新]
  ↓
3a7f2d9 [3 回目の更新]
  ↓
70e529a [2 回目の更新]
  ↓
dfb29ca [1 回目の更新]
```

※矢印は「子→親」を表す。角括弧 [ ] のなかはコミットメッセージ。

コミット 1720f58 [6 回目の更新] が2つの子コミットオブジェクトを持っています。

こういう枝分かれは、例えば以下のような状況でよく起こります。

* 複数の人が、あるバージョンに同時に異なる変更をした。
* 新機能のための実装を、2パターン作ってみた。
* 過去のあるコミットよる変更に、問題があったと気づく。そのコミットオブジェクトにブランチを作って、カレントブランチにした。そして、修正のための変更をコミットした。

そして、枝分かれを分かれっぱなしにすることはほとんどありません。
両方の分かれた枝に含まれる変更を「混ぜあわせて」、新しいバージョンを作りたくなるものです。
この「混ぜあわせる」操作を **マージ**(merge) といいます。

次回はマージについて解説します。
