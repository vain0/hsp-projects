# Gitのコミット

前回のギトギット！ (♬)

0. GitHub のアカウントを作った！
0. GitHub にリポジトリを作った！
0. GitHub リポジトリに git push してバックアップを作った！

[序文](README.md) で触れた内容は前回で完遂し、みなさんは git をバックアップツールとして使いこなせるようになりました。
さて、今回から **第2部** です。Gitの底力はまだまだこんなもんじゃないですからね！

いままで git add と git commit については、あまり詳しく話していませんでした。
今回はこれを詳しく解説します。

## コミットオブジェクト

いままで直接は説明しませんでしたが、git commit を行うと、「前回の git commit より後にした変更」がリポジトリに記録されます。
このときの「記録」のことを、まとめて1個の **コミットオブジェクト**(commit object) と呼びます。
(単にコミットと略すのが一般的です。)

コミットオブジェクトには、以下のような情報が記録されています。

* コミットメッセージ
* コミットした人のユーザ名とメアド
* 変更後のファイル
* 親コミットオブジェクトたちのハッシュ値
* (他にもありますが、省略)

上3つはみなさんもご存知でしょう。
気になるのは「親コミットオブジェクト」ですね。

コミットオブジェクトの間には親子関係があります。
[第5回 Gitの記録](chapter5.md) で使った git log の結果を引用して説明します。

```
$ git log --oneline
3456001 7 回目の更新  [= HEAD]
  ↓
1720f58 6 回目の更新
  ↓
99bd126 5 回目の更新
  ↓
96a691b 4 回目の更新
  ↓
3a7f2d9 3 回目の更新
  ↓
70e529a 2 回目の更新
  ↓
dfb29ca 1 回目の更新  [親なしコミット]
```

ここでの矢印は、「子 → 親」という関係を表しています。
git log は、最新のコミットオブジェクト 3456001 (= HEAD) から始めて、親へ親へと辿っていくことで、コミットオブジェクト (のハッシュ値とメッセージ) を列挙していたのです。

そう考えると、コミットオブジェクトというのは、「1回の変更」と言いましたが、 **1つのバージョンを表している** とみなすことも可能です。

## HEADの定義の更新
さて、 [第5回](chapter5.md) で HEAD を以下のように説明しましたが、(意図的な)誤りです。謝ります。

> HEAD とは「最後に git commit された変更」を表しているものです。

いままで私が説明したコマンドだけを使っているかぎり、上の理解でもある意味正しいのですが、これから次のステップに進むため、もう少し正確な説明を与えます。

* HEAD とは、作業ディレクトリが元にしているコミットオブジェクトを指し示す名前である。

よく分かりませんね。
関係代名詞があるので、とりあえず2つの文に分けてみます。

* HEAD とは、あるコミットオブジェクトを指し示す名前である。
* 作業ディレクトリは、そのコミットオブジェクトを元にしている。

コミットオブジェクトは「バージョン」を表していると前節でいいましたが、ここで、そのように言い換えてみましょう。
「コミットオブジェクト」→「バージョン」と書き換えます。

* HEAD とは、あるバージョンを指し示す名前である。
* 作業ディレクトリは、そのバージョンを元にしている。

なんだか分かりやすくなってきた気がしてきました。
あとは「作業ディレクトリが、あるバージョンを元にしている」という文の意味が分かれば攻略できそうです。

一応再確認ですが、作業ディレクトリは、git の管理下に置かれているディレクトリのことでしたね。.git の外側。
作業ディレクトリの現在の状態、すなわち作業ディレクトリ内のファイルに変更があるかどうかは、git status や git diff で確認できるのでした。
ここで気にしてほしいのは、「変更がある」というのは「何かと比較して、変更がある」ということです。
いままで、git status や git diff は、いま作業ディレクトリ内にあるファイルを、 **何と** 比較していたのでしょうか？
その答えが「元にしているバージョン」、すなわち HEAD です。

git status や git diff は、作業ディレクトリにあるファイルを、バージョン HEAD に記録されたファイルと比較していたのです。

> HEAD とは、作業ディレクトリが元にしているコミットオブジェクトを指し示す名前である。

このことが分かると、git add && git commit が何をするのかも、より詳しく説明できるようになります。

0. 作業ディレクトリはクリーンな状態。(すなわち、バージョン HEAD に記録されたのと同じ状態にある。)
0. 作業ディレクトリに変更を加える。
0. git add と git commit を行う。
  0. HEAD を **親** とする新しいコミットオブジェクトが作られる。
  0. HEAD が新しいコミットオブジェクトの名前に更新される。

確認のため、各種コマンドを実行するたびに、HEAD がどうなるかみてみましょう。

0. 作業ディレクトリを作る。
0. git init する。
  * HEAD はまだ存在しない。
  * このときのリポジトリにはコミットオブジェクトが存在しないので、「コミットオブジェクトの名前」であるところの HEAD も当然ありません。)
0. ファイルを作成する。
  * 同じく HEAD はありません。
0. git add と git commit を行う。
  * 新しいコミットオブジェクトが作成されます。
  * いま HEAD は存在していなかったので、そのコミットオブジェクトの「親」も存在しません。
  * そして、この新しいオブジェクトの名前として、HEAD が生まれます。
0. ファイルが変更される。
0. git add と git commit を行う。
  * 新しいコミットオブジェクトが作成されます。
  * その親は、現在の HEAD である、「最初のコミットオブジェクト」です。
  * そして、HEAD はこの新しいオブジェクトの名前になります。

このように前回までに説明したような、「ファイルの変更と git add && git commit を繰り返していく」ような使いかたをするぶんには、HEAD はいつも「最新のコミットオブジェクトの名前」になるんですね。

では HEAD が「最新のコミットオブジェクトの名前」ではなくなるのは、いつか？
次回に続きます。

## バージョンリープ

いままで、HEAD は常に「最新のバージョン」を表していました。
HEAD の位置を移動させてみましょう。
そのためには、基本的に git checkout を使います。

適当なリポジトリで bash を開き、作業ディレクトリをクリーンにしてから (つまり、git commit していない変更がないようにしてから)、以下のコマンドを実行してみてください。

```
$ git checkout HEAD~
```

※git checkout でファイルを取り出すには「git checkout -- ファイル名」としていましたが、この不自然な「--」は、上述のような「バージョンを取り出す用法」と区別するために必要だったのです。

すると、例えば以下のような表示になります。
長い英文が出てきますが、これは git からの親切な忠告です。無視します。

```
$ git co HEAD~
Note: checking out 'HEAD~'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b <new-branch-name>

HEAD is now at 1720f58... 6 回目の更新
```

ひとまず、第5回で作ったリポジトリで実行してみました。
``HEAD~``＝「6回目の更新後のバージョン」の状態を「取り出し」た、という状況です。
実際、作業ディレクトリは「6回目の更新の後」の状態になっています。
すなわち、 five.txt は7行目がなく、

```
ファイル作成！
1 行目！
2 行目！
3 行目！
4 行目！
5 行目！
6 行目！
```

となります。
単に7行目を消したのではなく、HEAD を移動したので、いま「作業ディレクトリには更新がない」(クリーンである)状態です。
確かめてみます。

```
$ git status
HEAD detached at 1720f58
nothing to commit, working directory clean
```

先ほどの git checkout コマンドにより、作業ディレクトリは「6回目の更新の後のバージョン」を元にしている状態になりました。
git status は HEAD＝「6回目の更新の後のバージョン」といまの作業ディレクトリを比較するので、変更は何もない、ということになります。

こうして、私たちは **擬似タイムトラベル** に成功しました。
すなわち、git checkout を使うことで、「昨日のバージョン」のような過去に作業ディレクトリをタイムスリップさせることができたのです。

## コミットオブジェクトの親子関係



おっと、この状態で新しくコミットオブジェクトを作ったらどうなるのでしょうか？

[次回]() は、git 時空に複数の世界線

## 参考文献
* [もうGitは怖くない： 自信を持って使いたいあなたへ - 檜山正幸のキマイラ飼育記](http://d.hatena.ne.jp/m-hiyama/20150928/1443397382) (2016年3月18日閲覧)
  * コミットグラフに関する、日本語で読めるかなり詳しい解説。
