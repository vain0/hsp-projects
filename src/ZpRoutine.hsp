// Zplayer - Routine

#ifndef IG_ZEOPLAYER_ROUTINE_AS
#define IG_ZEOPLAYER_ROUTINE_AS

//###########################################################
//        設定
//###########################################################
*ClearMainBeforeGameBeginning
	color_white : boxf
	clrobj
	
	//ゲームログ設置
	sdim gamelog, 1200
	pos 0, WIN_SIZEY - SizeY_GameLogBox : mesbox gamelog,  WIN_SIZEX, SizeY_GameLogBox,  (mesbox_disable | mesbox_vscroll)
	objIdGameLogBox = stat
	return
	
//###########################################################
//        画面の描画
//###########################################################
//-------------------------------------------------
// トップ画面の描画
// あとボタンがある
//-------------------------------------------------
*RedrawTitle
	gsel wID_Main
	redraw 2
	color_graylight : boxf
	hsvcolor ,, 225 : boxf
	
	// タイトルをでかでかと描画
	color: font msgothic, 160
	pos 70, 50 : mes "ZeoFive"
	
	// デッキのカードを5枚並べる
	repeat 5
		pos_x = 80 + (110 * cnt)		// 描画基点
		
		pos pos_x, 240
		if ( deckpath(w) == "" ) {
			DrawCardBack
		} else {
			DrawBlueCard cnt
		}
		//白で縁取り
		color_white: boxl pos_x, 240, pos_x + 90, 350
	loop
	
	// 三色の線を引く
	repeat 3
		// 赤緑青
		hsvcolor 120 * cnt, 255, 255
		;color 255 * (cnt == 0), 255 * (cnt == 1), 255 * (cnt == 2)
		boxf , 360 + (3 * cnt),  , 363 + (3 * cnt)
		;repeat 3, 380 + (3 * cnt)
		;	line -1, cnt, WIN_SIZEX, cnt
		;loop
	loop
	redraw
	return
	
//-------------------------------------------------
// 画面をきれいにする
//-------------------------------------------------
*ClearCombatWindow
	assert_sentinel /*
	gsel wID_Battle
	pos WPx +  25, WPy + 50 : gcopy wID_SC_Red_B , 0 ,0, 272, 332	// 敵カード貼り付け作業
	pos WPx + 321, WPy + 50 : gcopy wID_SC_Blue_B, 0, 0, 272, 332	// 自分のカード貼り付け作業
	
	// カード名部分の背景色を上書き
	dim iPos, Count_Players
	repeat Count_Players
		color32 ClassColorref(cardcls(player(cnt), cnt), cnt)
		if ( cnt == w ) {
			iPos(0) = WPx + 321
			iPos(1) = WPy +  50
			boxf iPos(0) + 16, iPos(1) + 16, iPos(0) + 254, iPos(1) + 65
		} else {
			iPos(0) = WPx + 25
			iPos(1) = WPy + 50
			boxf iPos(0) + 16, iPos(1) + 268, iPos(0) + 254, iPos(1) + 312
		}
	loop
	return//*/
	
//-------------------------------------------------
// 戦闘画面を再描画する
//-------------------------------------------------
*RedrawCombat
	assert_sentinel/*
	// 画面の位置をメインウィンドウに合わせる (元々戦闘画面が全画面だったことの名残り)
	// ウィンドウフレームの分が合わないが
	gsel wID_Main
	posMainWindow = ginfo_wx1, ginfo_wy1
	
	gsel wID_Battle
	width ,, posMainWindow(0), posMainWindow(1)
	redraw 2
	gosub *ClearCombatWindow		// 書く前に画面をきれいにする
	
	if ( bPic ) {
		pos WPx + 337, WPy + 132
		gzoom 239, 128, wID_wCardPic + player(w), 0, 0, LOWORD(scrs(player(w))), HIWORD(scrs(player(w)))
	}
	
	color
	
	// 自分のカードに自分の能力を描画
	font "", 38, 16
	pos WPx + 342, WPy +  68 : mes ourName
	
	font "", 40 : if ( bAttackPlayer == e ) { color 255, 255 } else { color }
	pos WPx + 344, WPy + 275 : mes "HP"+ ourHP  : color
	pos WPx + 480, WPy + 275 : mes "S" + ourSPD : if ( bAttackPlayer == w && Ability(w) == 1 ) { color 255, 255 } else { color }
	pos WPx + 345, WPy + 320 : mes "A "+ ourATK : if ( bAttackPlayer == w && Ability(w) == 0 ) { color 255, 255 } else { color }
	pos WPx + 480, WPy + 320 : mes "I "+ ourINT
	
	color
	
	// 敵のカードに描画
	font "", 38
	pos WPx + 43, WPy +320 : mes emyName
	
	font "", 40 : if ( bAttackPlayer == w ) { color 255, 255 } else { color }
	pos WPx +168, WPy +120 : mes "HP" + emyHP  : color
	pos WPx + 51, WPy +120 : mes "S " + emySPD : if ( bAttackPlayer == e && Ability(e) == 1 ) { color 255, 255 } else { color }
	pos WPx +168, WPy + 70 : mes "A " + emyATK : if ( bAttackPlayer == e && Ability(e) == 0 ) { color 255, 255 } else { color }
	pos WPx + 51, WPy + 70 : mes "I  "+ emyINT
	
	redraw
	return//*/
	
//-------------------------------------------------
// 小戦闘画面
//-------------------------------------------------
*RedrawMain
	redraw 2
	
	// 背景で塗りつぶす
	pos 0, 0 : gcopy wID_Back, ,, WIN_SIZEX, WIN_SIZEY
	
	repeat Count_CardsInDeck
		pos_x = 50 + (110 * cnt)  // 描画基点
		gosub *DrawOurCards
		gosub *DrawEnemyCards
	loop
	return
	
//-------------------------------------------------
// 仲間のカードを描画
// 
// @ cnt が番号
//-------------------------------------------------
*DrawOurCards
	if ( HP(cnt, w) > 0 ) {
		//ゲーム開始時の初手は手持ち側に配置
		if ( cnt == player(w) && bBeginning == false ) {
			pos pos_x, 260 : DrawBlueCard cnt, true
		} else {
			pos pos_x, 380 : DrawBlueCard cnt
		}
	} else {
		// 棺桶
		pos pos_x, 380 : DrawCardCoffin
	}
	return
	
//-------------------------------------------------
// 敵のカードを描画
// 
// @ cnt が番号
//-------------------------------------------------
*DrawEnemyCards
	if ( HP(cnt, e) > 0 ) {
		if ( cnt == player(e) && bBeginning == false ) {
			// 戦闘カード
			pos pos_x, 134 : DrawRedCard cnt, true
		} else {
			// 手持ちのカード (裏面)
			pos pos_x,  10 : DrawCardBack;gcopy wID_SC_Back, 0, 0, SizeX_Card, SizeY_Card
		}
	} else {
		// 棺桶
		pos pos_x, 10 : DrawCardCoffin
	}
	return
	
//###########################################################
//        ゲーム中の動作
//###########################################################
//-------------------------------------------------
// 自分 -> 次のカードを選択する
//-------------------------------------------------
*W_SelectCard
	redraw 2
	gosub *RedrawMain
	
/*
	font "", 64
;	color 192, 192, 192		// 灰色
	color 225, 225, 225 : boxf 70, 215, 600, 360
	color 192, 192, 192 : boxl 70, 215, 600, 360
	
	color
	pos 80, 225 : mes "場に出すカードを\n    選んでください。"
/*/
;	hsvcolor ,, 192		// 灰色
	hsvcolor ,, 225 : boxf 50, 510, 580, 640 - SizeY_GameLogBox
	hsvcolor ,, 192 : boxl 50, 510, 580, 640 - SizeY_GameLogBox
	
	color
	font msgothic, 33
	pos 60, 525 : mes "場に出すカードを選んでください"
//*/
	
	objsize 89, 26
	// 押したボタンの ID 値が *Decide_CardIntoPlay の stat 値になる
	repeat Count_CardsInDeck
		if ( HP(cnt, w) <= 0 ) {				// 死者
			declvar __dummy
			input __dummy, 0, 0
		} else {
			pos (110 * cnt) + 51, 381			// カード名と被る位置に置く
			button gosub cardname(cnt, w), *Decide_CardIntoPlay
		}
		if (cnt == 0) { objIdFirstCard = stat }
		assert (stat == objIdFirstCard + cnt)
	loop
	redraw
	
	bDecided = false
	while ( bDecided == false ) : await 70 : wend
	return
	
//-------------------------------------------------
// 自分 -> 次に場に出すカードを決定する
//-------------------------------------------------
*Decide_CardIntoPlay
	bDecided = true
	num      = stat - objIdFirstCard
	ChangeCard w, num
	
	//カード選択ボタンを消去
	clrobj objIdFirstCard, objIdFirstCard + Count_CardsInDeck - 1
	
	redraw 2
	color_white : boxf
	gosub *RedrawMain
	redraw
	return
	
//-------------------------------------------------
// 相手 -> 次に場に出すカードを選ぶ
// 
// スピードが上回っているか、次の攻撃を耐えられて、
//	なおかつ相手を倒せる技を持つカードのうち、
//	その技の威力が最小のものを出す。なければランダム。
//-------------------------------------------------
*E_SelectCard
	num = -1
	
	// こちら側の攻撃方法が未定 => ゲームの開始時の選択 (こちら側のカードの情報を使ってはいけない)
	if ( Ability(w) < 0 ) {
		// ランダム
	} else {
		ourNextDamage = cond_i(Ability(w), ourATK, ourINT)	// 次に受けるダメージ量
		emyNextDamage = 0x7FFFFFFF	// 番兵値
		repeat Count_CardsInDeck
			if ( (HP(cnt, e) > 0 && S(cnt, e) > ourSPD) || HP(cnt, e) > ourNextDamage ) {
				if ( A(cnt, e) >= ourHP && emyNextDamage >= A(cnt, e) ) {
					num = cnt : emyNextDamage = A(cnt, e)
				}
				if ( I(cnt, e) >= ourHP && emyNextDamage >= I(cnt, e) ) {
					num = cnt : emyNextDamage = I(cnt, e)
				}
			}
		loop
	}
	
	// 思考ルーチンが答えを出さなかったらランダムに選ぶ
	if ( num < 0 ) {
		do: num = rnd(5)
		until ( HP(num, e) > 0 )
	}
	ChangeCard e, num			// 変更
	return
	
//-------------------------------------------------
// 自分 -> 攻撃方法の選択
//-------------------------------------------------
;#define objIdAttackByPhysics 1
;#define objIdAttackByMagic   2
*W_SelectWayToAttack
	// 1だと魔法なし、0だと物理なし、どちらでもなければ両方選べる
	PutTwoObjectsOnBattleWindow *LPhysicsButton, *LMagicButton
	
	bDecided = false
	while ( bDecided == false ) : await 120 : wend
	return
	
*LPhysicsButton:
	if ( Ability(w) != 0 ) { button gosub " 物理で攻撃！", *Decide_WayToAttack } else { input num, 0, 0 }
	objIdAttackByPhysics = stat
	return
*LMagicButton:
	if ( Ability(w) != 1 ) { button gosub " 魔法で攻撃！", *Decide_WayToAttack } ;: assert (stat == objIdAttackByMagic)
	return
	
//-------------------------------------------------
// 自分 -> 攻撃方法の選択を決定する
//-------------------------------------------------
*Decide_WayToAttack
	bDecided   = true
	Ability(w) = (stat == objIdAttackByPhysics)	// 物理を押したら、真(= 物理攻撃)
	clrobj objIdAttackByPhysics, objIdAttackByPhysics + 1; objIdAttackByMagic
	return
	
//-------------------------------------------------
// 相手 -> 攻撃方法を決定する
//-------------------------------------------------
*E_SelectWayToAttack
	if ( Ability(e) >= 0 ) { return }	// 決定済み
	
	// どちらでも殺せるなら、小さい方で攻撃 (同じならATK)
	if ( ourHP <= emyATK && ourHP <= emyINT ) {
		Ability(e) = ( emyATK <= emyINT )
		
	// 大きい方で攻撃 (同じならATK)
	} else {
		Ability(e) = ( emyATK >= emyINT )
	}
	return
	
//###########################################################
//        その他
//###########################################################
//-------------------------------------------------
// ブラウザでルールを設定する
//-------------------------------------------------
*Rule
	exec ownpath + "/rule.html", exec_application
	return
	
#endif
