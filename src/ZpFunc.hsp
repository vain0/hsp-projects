// Zplayer - Function

#ifndef IG_ZEOPLAYER_FUNCTION_AS
#define IG_ZEOPLAYER_FUNCTION_AS

//-------------------------------------------------
// ダイアログでデッキを開く
//-------------------------------------------------
#deffunc OpenDeckWithDialog int idPl,  local lcpath
	chdir ownpath + "/decks"
	dialog "zeo_d", 16, playerName(idPl) + "用デッキファイル"
	if (stat == 0) { return true }
	
	lcpath = refstr
	LoadZeoDeck idPl, lcpath
	if (stat) { return stat }
	
	deckpath(idPl) = lcpath
	return false
	
//-------------------------------------------------
// デッキ読み込み
//-------------------------------------------------
#deffunc LoadZeoDeck int idPl, str path, int bNoPics,  local lcname, local lprms, local lpicdat
	sdim lcname, 20, 5
	dim  lprms,   5, 5
	sdim lpicdat, MAX_PATH, 5
	
	DeckLoad path, lcname, lprms, lpicdat
	if ( stat ) { return stat }
	
	// パラメータをグローバル変数にコピー
	repeat Count_CardsInDeck
		cardname(cnt, idPl) = lcname(cnt)
		HP(cnt, idPl) = lprms(0, cnt)
		S (cnt, idPl) = lprms(1, cnt)
		A (cnt, idPl) = lprms(2, cnt)
		I (cnt, idPl) = lprms(3, cnt)
		cardcls(cnt, idPl) = lprms(4, cnt)
	loop
	
	if (bNoPics == false) {
		// カード画像をバッファする
		repeat Count_CardsInDeck
			picdat(cnt, idPl) = lpicdat(cnt)
			if (picdat(cnt, idPl) == "") { continue }
			
			exist picdat(cnt, idPl)
			if ( strsize < 0 ) {
				dialog "カード「" + cardname(cnt, idPl) +  "」の画像が見つかりません。\n" + picdat(cnt, idPl), 1, Str_GameName
				picdat(cnt, idPl) = ""
				continue
			}
			
			buffer cond_i(idPl == w, wID_wCardPic, wID_eCardPic) + cnt
			picload picdat(cnt, idPl)
			scrs(cnt, idPl) = MAKELONG(ginfo_sx, ginfo_sy)
		loop
	}
	return false
	
//-------------------------------------------------
// メイン画面に2つのオブジェクトを配置する
// 「物理/魔法」「続ける/終わる」ボタン
//-------------------------------------------------
#define PutTwoObjectsOnBattleWindow(%1,%2) \
	objsize 260, 130 - SizeY_GameLogBox :\
	objmode objmode_usefont : font msgothic, 37 :\
	pos  50, 510 : gosub (%1) :\
	pos 340, 510 : gosub (%2) : objmode objmode_guifont :
	
//-------------------------------------------------
// ゲーム決着
//-------------------------------------------------
#deffunc GameOver int idPl,  local msg
	redraw 2
	gosub *RedrawMain
	
	msg = "You "+ cond_s(idPl, "win", "lose") +"..."
	;AddGameLog "あなたの" + cwhich(idPl, "勝ちです！", "負けです……")
	
	//勝敗を影付きで大きく表示
	font msgothic, 90, 3
	pos 88, 243 : mes msg
	
	font msgothic, 90
	if ( idPl ) { color ,, 255 } else { color 255 }
	
	pos 90, 245 : mes msg
	color
	
	//続けるかどうかのボタン
	PutTwoObjectsOnBattleWindow *LContinueButton, *LExitButton
	redraw
	
	bGameOver ++
	return
	
*LContinueButton:
	button "続ける", *LContinue : return
*LExitButton:
	button "終わる", *LExit : return
	
//-------------------------------------------------
// どちらの方が早いかを判定する関数
//-------------------------------------------------
#defcfunc JudgeSPD  local num
	if ( ourSPD == emySPD ) {
		// 王が勝つ
		if ( ourMOV == 0 && emyMOV != 0 ) { return w }
		if ( emyMOV == 0 && ourMOV != 0 ) { return e }
		
		// ほぼランダムに決める
		dim num, 2
	//	num(0) = HPの減り具合が大きい方 (自分 = 0, 相手 = 1)
		num(0) = ((MAX_PRM - (ourSPD + ourATK + ourINT) - ourHP) >= (MAX_PRM - (emySPD + emyATK + emyINT) - emyHP))
		num(1) = rnd(5) \ 2			// 0, 1, 0, 1, 0
		
		return num(0) ^ num(1)		// 受けているダメージの少ない方が有利 (少 : 多 = 3 : 2)
	
	} else {
		assert ((ourSPD < emySPD) == cond_i(ourSPD < emySPD,  e, w))
		return (ourSPD < emySPD)
	}
	
//-------------------------------------------------
// 死んでいるかどうかを判定する関数
//-------------------------------------------------
#defcfunc WasKilled int idPl
	if ( HP(player(idPl), idPl) <= 0 ) {
		 HP(player(idPl), idPl)  = 0
		return true
	}
	return false
	
//-------------------------------------------------
// 死んだ後の処理をする命令
//-------------------------------------------------
#deffunc Die int idPl
	if ( Heads(idPl) <= 0 ) { GameOver idPl : return }
	
	AddGameLog playerName(idPl) + "の「" + cardname(player(idPl), idPl) + "」は倒れた。"
	
	player(idPl) = -1
	if ( idPl == w ) {
		gosub *W_SelectCard
	} else {
		gosub *E_SelectCard
	}
	return
	
//-------------------------------------------------
// 戦闘カードを変更する命令
//-------------------------------------------------
#deffunc ChangeCard int idPl, int idCard
	player (idPl) = idCard
	Heads  (idPl) --			// 頭数を減らす
	Ability(idPl) = -1		// 技使用状況をリセット
	
	if (Heads(idPl) < 0) {	// ゲーム終了
		GameOver idPl			// 自分(0)なら敗北、敵(1)なら勝利
	} else {
		AddGameLog playerName(idPl) + "は「" + cardname(idCard, idPl) + "」を召喚。"
	}
	return
	
//-------------------------------------------------
// HP を減少させる命令
// 実際のデータをだんだん減らしつつ、再描画を繰り返す
//-------------------------------------------------
#deffunc DealDamage var _hp, int attackprm,  local aftHP
	if ( attackprm == 0 ) { return }
	
	aftHP = limit(_hp - attackprm, 0, 200)	// 最終的なHP残量
	
	// 初期値と目標値を設定する
	m_SetValChgPrbr 0, _hp, afthp, attackprm / 5
	await 500
	repeat
		m_GetValChgPrbr 0, double(aftHP)
		_hp = int(refdval)
		
		;gosub *RedrawCombat
		gosub *RedrawMain : redraw
		await 60
		
		if ( refdval == double(aftHP) || _hp <= 0 ) { break }
	loop
	return
	
//-------------------------------------------------
// 攻撃する命令
// idAP: attacking player
//-------------------------------------------------
#deffunc Attack int idAP,  local idBP, local attackprm
	idBP = (idAP == 0)
	AddGameLog cardname(player(idAP), idAP) + "の" + cond_s(ability(idAP), "物理", "魔法") + "攻撃！" 
	
	;gosub *RedrawCombat		// 拡大戦闘画面のセット
	;gsel wID_Battle, 1
	
	// ダメージを与える
	attackprm = cond_i(ability(idAP), A(player(idAP), idAP), I(player(idAP), idAP))
	DealDamage HP(player(idBP), idBP), attackprm
	
	// 攻撃終了
	;gosub *RedrawCombat		// 最終調整
	;await 1200
	;gsel wID_Battle, gsel_hide
	gsel_show wID_Main
	
	gosub *RedrawMain
	redraw
	await 500
	
	// 攻撃方法を反転する
	Ability(idAP) ^= 1
	
	// 死んでいたら真を返す
	if ( HP(player(idBP), idBP) <= 0 ) {
		return true
	}
	return false
	
//###########################################################
//        描画命令
//###########################################################
#define DrawCardCommit gsel wID_Main: gcopy wID_CardTemp,  ,, SizeX_Card, SizeY_Card

#define DrawCardBack   gcopy wID_CardBack,  ,,  SizeX_Card, SizeY_Card
#define DrawCardCoffin gcopy wID_CardCoffin,  ,,  SizeX_Card, SizeY_Card

//-------------------------------------------------
// 味方の白紙カード
//-------------------------------------------------
#define DrawBlueCardBlank gosub *LDrawBlueCardBlank
*LDrawBlueCardBlank
	color   , 200, 255  // 表面
;	color 23, 134, 255  // 成り
	boxf
	
	//カード名
	;color 175, 238, 255: boxf 6, 6,  84, 21
	//イラスト
	;color_graylight: boxf 6, 28, 84, 69
	
	//枠
	color
	boxl , ,     90, 110  // 外枠
	boxl 5,  5,  85, 22   // 名前枠
	boxl 5, 27,  85, 70   // イラスト枠
	return
	
//-------------------------------------------------
// 逆向き白紙カード (敵の場カード)
//-------------------------------------------------
#define DrawRedCardBlank gosub *LDrawRedCardBlank
*LDrawRedCardBlank
	color 220, 20, 60
;	color 192, 11, 11
	boxf
	
	//カード名
	;color 255, 120, 120: boxf 6, 89, 84, 104
	//イラスト
	;color_graylight: boxf 6, 41, 84, 84
	//枠
	color
	boxl , ,     90, 110  // 外枠
	boxl 5, 88, 85, 105   // 名前枠
	boxl 5, 40, 85,  85   // イラスト枠
	return
	
//-------------------------------------------------
// カードの影
//-------------------------------------------------
*LDrawCardShadow
	hsvcolor ,, 125
	boxf ginfo_cx + 5, ginfo_cy + 5,  ginfo_cx + 96, ginfo_cy + 116
	return
	
//-------------------------------------------------
// 自分側のカードを描画
//-------------------------------------------------
#deffunc DrawBlueCard int idCard, int bShadow
	if (bShadow) { gosub *LDrawCardShadow }
	
	gsel wID_CardTemp
	assert (HP(idCard, w) > 0)
	
	DrawBlueCardBlank
	
	// 階級に応じた色で塗る
	color32 ClassColorref(cardcls(idCard, w), w)
	boxf 6,  6,  84,  21   // カード名背景
	repeat 2, 1 : boxl , , SizeX_Card - cnt, SizeY_Card - cnt : loop  // 外枠の内側2本
	
	// カードイラスト
	if (picdat(idCard, w) != "") {
		pos 6, 28 : gzoom 78, 43,  wID_wCardPic + idCard,  , ,  LOWORD(scrs(idCard, w)), HIWORD(scrs(idCard, w))
	} else { color_graylight: boxf 6, 28, 84, 69 }
	
	// パラメータ
	font_cardtext : color
	pos  8,  8 : mes cardname(idCard, w)
	pos  6, 75 : mes strf("H%4d", HP(idCard, w)) : if ( player(w) == idCard && player(e) >= 0 ) { if ( ourSPD >= emySPD ) { color 255, 255 } }
	pos 52, 75 : mes strf("S%4d",  S(idCard, w)) : if ( player(w) == idCard && Ability(w) == 1 ) { color 255, 255 } else { color }
	pos  6, 92 : mes strf("A%4d",  A(idCard, w)) : if ( player(w) == idCard && Ability(w) == 0 ) { color 255, 255 } else { color }
	pos 52, 92 : mes strf("I%4d",  I(idCard, w))
	
	DrawCardCommit
	return
	
//-------------------------------------------------
// 相手側のカードを描画する
//-------------------------------------------------
#deffunc DrawRedCard int idCard, int bShadow
	if (bShadow) { gosub *LDrawCardShadow }
	
	gsel wID_CardTemp
	assert ( HP(idCard, e) > 0 )
	
	// カード表面
	DrawRedCardBlank
	;pos x, y : gcopy wID_SC_Red, 0, 0, SizeX_Card, SizeY_Card
	
	// カード名部分
	color32 ClassColorref(cardcls(idCard, e), e)
	boxf 6, 89,  84, 104
	repeat 2, 1 : boxl , , SizeX_Card - cnt, SizeY_Card - cnt : loop  // 外枠の内側2本
	
	// イラスト
	color_graylight: boxf 6, 41, 84, 84
	
	// パラメータ記入
	font_cardtext : color
	pos  8, 90 : mes cardname(idCard, e)
	pos 48, 24 : mes strf("H%4d", HP(idCard, e)) : if ( player(e) == idCard && player(w) >= 0 ) { if ( emySPD >= ourSPD ) { color 255, 255 } else { color } }
	pos  6, 24 : mes strf("S%4d", S(idCard, e)) : if ( player(e) == idCard && Ability(e) == 1 ) { color 255, 255 } else { color }
	pos 48,  6 : mes strf("A%4d", A(idCard, e)) : if ( player(e) == idCard && Ability(e) == 0 ) { color 255, 255 } else { color }
	pos  6,  6 : mes strf("I%4d", I(idCard, e))
	
	DrawCardCommit
	return
	
//-------------------------------------------------
// ゲームログを追加する
//-------------------------------------------------
#deffunc AddGameLog str msg
	gamelog += "\n" + msg
	objprm objIdGameLogBox, gamelog
	
	//カーソルを末尾に移動
	#define EM_SETSEL      0x000000B1
	#define EM_SCROLLCARET 0x000000B7
	sendmsg objinfo_hwnd(objIdGameLogBox), EM_SETSEL, , -1
	sendmsg objinfo_hwnd(objIdGameLogBox), EM_SCROLLCARET
	return
	
#endif

