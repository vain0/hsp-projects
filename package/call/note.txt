
	ノート(note)
	
	( 自分用 )
	
＠覚え書き
	・comobj型メソッドの戻り値が comres で設定した変数に格納されるのは、メソッド
		呼び出し機構の仕様ではなく、comobj 型のみの仕様。
		※comres は win32gui 内で、mcall は hsp3code.cpp で定義されている。
		
	・ラベル型変数の PVal::pt は unsigned char*[] で、aptr を配列要素とする。
		各要素には、ラベルポインタ( code_call などに渡せるもの )がはいっている。
		
	・ラベル定数の val はラベルID、すなわち ctx->mem_ot の配列要素。
		(ctx->mem_ot[*val] + ctx->mem_mcs) はラベルの実行ポインタを返す。
		
	・OpenHSP::hsp3code.cpp で用意されている code_getlb2() が、プラグイン側で
		いうところの code_getlb() にあたる。OpenHSP での code_getlb() では、
		label を peek するだけで pop しない。
		
	・#deffunc のエイリアスは、専用の関数 code_get_proxyvar() で展開される。
		var 渡しの場合、参照されるたびに offset に正しい aptr が設定される仕様。
		local 変数は、prmstack 上に PVal 自体が配置されている。
		
	・dllfunc の呼び出しには、関数ポインタをアセンブリを用いて呼び出している。
		手を出していい気配ではない……。
		@ win32gui/hsp3extlib.cpp
		呼び出されると、引数を展開して call_extfunc ( ほとんどが inline アセン
		ブリ ) が実行される。
		仮引数の管理には STRUCTPRM が使われている。
		
	・クリーンアップ命令は #defcfunc じゃダメらしい。
		
	・HSP3TYPEINFO 構造体を得ることはできないものか。
		そしたら STRUCTDAT::index の呼び出し形式縛りを解放できるのだが。
		@→ プラグイン type 値の逆算で求めることが出来る (黒魔術)。
		
	・CCall::mpvThis がある場合、makePrmStack の前に prmstack にそれを push。
		そうすれば #deffunc での第一引数が this になるが、argc() の数に影響なし。
		→ やってみたが、なんか実行時エラーになるっぽい。
		どうしても #deffunc のようなランタイムレベルのサポートが必要なのか……？
		→ この実行時エラーは、CPrmStack が確保するメモリが固定長で、メモリアク
			セス違反していたから起きたようだ。
		現在はこの仕様で運用中。
		
	・参照渡しがネックだなぁ。「クローン」「PVal*」「PValコピー」3つの方法を試し
		たけど、どれも今ひとつ。唯一バグの元にならないのが「クローン」だったので、
		それを採用したが……。
		
	・deffid は TYPE_MODCMD の値、つまり ctx->mem_finfo[] の添字となる値。

	・演算の流れ
	[非破壊] a + b
		a, b が変数としてスタックにプッシュされる。
		演算子 + が取り出され、code_calcop() が呼ばれる：
			スタックの上から2つを Peek する。
			左辺のデータを、テンポラリ変数(mpval)に代入する。
			必要なら右辺を型変換する (右辺は ptr, flag の組だけで扱う)。
			HspVarProc の演算関数を実行する。
				ただし、両方 int なら呼び出さずにする (最適化処理)。
			スタックの上から2つを Pop する。
			演算結果を、対応する型の値としてプッシュする。
				mpval->pt を、varproc->aftertype の型として処理している。
	[破壊] a += b
		cmdfunc_var():
			左辺の変数が code_getva() により取得される。
			[加減] ++ か -- なら、int 型に変換して + 1 か - 1 して終わり。
			右辺の値を code_get() で取り出す。
			[単純代入]
				(省略)
			[複合代入]
				右辺の値を、左辺の型に合わせて変換する。
				HspVarProc の演算関数を実行する。
	・g_pMethodlist がメモリリークしてるんだけど std::auto_ptr にしたら終了時にビープ音が鳴る。
		しかもデストラクタが実行される前に死ぬ。
		
	・引数の取り出しの途中に他のコードを実行する場合、
		(type, val, exflg) はローカルで保存し、再開時に Restore する必要がある。
		
	・HSPのバグで、array か local 変数が連想配列型 ( functor 含む ) のとき、
		それを添字なしで右辺値として参照できない。
		@ 回避策がない。
		
	・引数の呼び出し後、その次の呼び出し前に サブルーチンジャンプをすると、
		前後で exflg が変化してしまうことに注意しよう。
		@ code_get などで引数式を1つ解析した後は、次の引数の先頭項が持つ EXFLG_2 を落としてから返るんだけれど、
		@ その後に code_call をすると、戻ってきた時に次の引数の先頭項を再取得して、EXFLG_2 がついたままになってしまう。
	・http://hsp.tv/play/pforum.php?mode=all&num=64858
		特定の関数の STRUCTDAT を丸々、呼びたい関数のものに書き換えてから、
		その関数を呼ぶことで、動的に呼び出し先を決定することができる。
	
＠更新履歴
2008 11/09 (Sun)
	・初期バージョン完成。
	
2008 11/10 (Mon)
	・全引数のデータをPValで管理するように修整。
	　→ call_argv で一元的に参照可能になった。
	・モジュール命令 refarg を追加。
	・call_thislb を実装。
	
2008 12/11 (Thu)
	・関数形式呼び出しで、p1に型名を指定しなくてもいいようにした。
	　code_call()内部ですべて終了していることに気付く。
	　※以前は、ラベル関数の第一引数に戻り値の型を書く必要があった。
	　　これは、プラグイン関数の戻り値を、呼び出し時に特定するため。
	　　が、そんなことする必要はなかった。( gosub した中ですべての
	　　処理が完了する仕様だったため(HSPの仕様が) )
	・call_exitではなく、普通に return で戻れるようにした。
	・call_initの廃止。
	　"実行開始処理" 命令だったが、実際は変数を一括して引数の
	　エイリアスにする call_aliasAll と同様だった。
	・call_result命令 → call_regvar命令に改名。
	　関数の戻り値を受け取る変数をプラグインに登録する命令。
	・call_result関数を追加。
	　call_retvalで設定された値を取得する関数。
	
2008 12/12 (Fri)
	・ctx->prmstack を更新して、#deffunc を使った記述を可能にした。
	・note.txt(これ)を作成。
	
2008 12/27 (Sat)
2008 12/28 (Sun)
	# 前日からの続き。
	・call_regvar廃止。戻り値用のPValはプラグインの
	　内部で管理するようにした。
	・関数形式呼び出しの時、return の戻り値を優先して使うようにした。
	・CArgInfoクラスを作り、若干オブジェクト指向っぽくしてみた。
	　バックアップが消えかけて、てんやわんやな事態だったが。
	
2008 12/30 (Tue)
	・call_result関数が MGetRetVal の戻り値を返していたために
	　メモリ違反になっていたのを修整し、g_respval を返すようにした。
	・call_hs をプラグインの内容に合うように再編集。
	
2009 01/29 (Thu)
	・call_retval命令が使われていて、returnで何も返さなかった場合に、
	　システム変数にcall_retvalの値をセットしようと試みたが、失敗。
	・引数の値を std::vector で扱うように変更。本当の可変長引数が
	　可能になった。
	　( それまでは固定長配列 (PVal*)[16] を利用していた )
	
2009 08/07 (Fri)
	・method の機能を追加。( method_replace, method_add )
		この時期は method.hpi として分離、後に統合。
	・参照渡しを、変数クローンではなく PVal* で渡すように変更。
	
2009 08/10 (Mon)
	・call に統合、バックアップ。
	・参照渡しを、「PVal 構造体のコピー」で渡すように変更。
		同じ引数に同じ配列変数を複数回渡すと、オフセット値が変化してしまうため。
		これで大丈夫なのかどうか不安だが……。
		
2009 08/11 (Tue)
	・メンバ関数の命名規則を「M + 大文字から始まるキャメルタイプ」から、
		STLと同じモノに変更。
	・pExec_t と label_t の間に差がなくなったので、というか後者を一切使用して
		いない状態になったので、前者を削除し、すべて label_t に統一。
	・ストリーム呼び出しを実装。
	・call() でストリーム呼び出しができないように変更 ( 通常のと区別できない )。
	・参照渡しを、「PVal 構造体のコピー」ではなく、pval ポインタと offset 値で
		渡すように変更……したが。
		→ 以前の方法では、型が変わるなどで pt メンバが変化したときなどに、元の
			変数が参照できていない。
		しかし、同時に同じ配列変数が異なる添字で渡されている場合、正しく処理でき
		ないので、仕方なく先祖返り。型が変わったら参照できなくなるのは仕様としか
		言いようがない……。
	・命令形式、関数形式を纏めて Call() に任せた。
	
2009 08/13 (Thu)
	・StCall 構造体を CCallData クラスに変更。
	・参照渡しを明示的に要求できるよう修整 ( PRM_TYPE_* の実装 )。
	・this の分 CPrmStack がメモリ破壊を起こしていたバグを修正。
		CPrmStack が、動的にメモリを伸ばせるように修整。
	・↑の過程で、CPrmStack を .cpp と .h に分離。
	・型チェックを強化。
	・仮引数つき call で、省略したときに、組み込み基本型( str, double, int )なら
		既定値を渡すように修整 ( いずれも HspVarProc::Alloc の直後の値 )。
	・既定値の PVal を、必要なときに動的に作るように変更。
		起動時オーバーヘッドを若干軽減……できたらいいね。
		また、関数で取得するようになったので、なんか仕様変更に強くなった気分。
	
2009 08/15 (Sat)
	・CCallData を CArgInfo が持つように変更。
		CArgInfo はもはや CCall に改名した方がいいのか……？
		CCallData は CCallPrm の方が適切な気がしてきたぞ……？
	
2009 08/16 (Sun)
	# 前日からの続き。
	・prmstack に、HSPとほぼ同じ形式で積むように修整 ( CCallDataがある場合のみ )。
	・call ユーザ定義命令, arg... の形式に対応。
		が、call ユーザ定義関数(), arg... との見分けが付かないため、没。
	・call id, arg... の形式に対応。
		id := ( ユーザ定義命令の id | MODCMDID_MAGIC_CODE ) $int;
		マジックコードは現在 0x2C000000、すなわち最上位バイトが 0x2C になる。
	・call を modfunc, modcfunc の modcmdid 値に対応。
	・参照渡しを、仮引数がない場合はクローンで、ある場合は PVal *, APTR の組で、
		渡すように変更。
	・仮引数リストがある場合、参照渡しを要求しない引数に、左辺値が指定された場合
		でも、参照渡ししないように変更。
	
	# 睡眠後。
	・CArgInfo が HSPCTX::prmstack へのポインタを保持するように変更。
	・仮引数宣言がある場合のみ、ローカル変数を追加できるように変更。
		……したが、なんかまだ問題がありそうなので中止。
	
2009 08/17 (Mon)
2009 08/18 (Tue) (睡眠前)
	・大幅なリファクタリング。
		・理由：CArgInfo の神クラス化、cmd_sub の無節操な肥大化。
		・ラベル命令・関数の呼び出しに関する情報を、すべて CCall が持つようにし、
			実引数は CCall が CArgData (元 CArgInfo) を所有する (ポインタ) よう
			変更した。
		・仮引数情報クラス CCallData の名前がぶっとんで不適切なので、CPrmInfo に
			改称した。これの動作や立場は変化なし。
		・call処理を行うクラス CCaller を作成、cmd_sub の内容はほとんどこれの
			メンバに変更された。CCaller は CCall をポインタで包含する。
			※callする権利は CCaller 以外のクラスにはない。
		・引数の取得関数、PValの作成・解放、既定値PValなど、汎用的な処理を
			hpimod にモジュールとして分解した。
		・独自スタック操作関数の PopCallStack()(元 PopArgStack())が、なぜか 
			CCall (元は CArgInfo) を delete していたので、これの delete 権を 
			CCaller に移動。
		
		・問題点：CCall が CArgData のメンバ関数をほとんどすべて持ち、美しくない。
	
	# 睡眠後。
	・ラベル命令・関数の仮引数宣言を行う call_dec 命令を追加。
	・仮引数タイプの取得に、code_getvartype() ではなく code_getprmtype() という
		特化した関数を用いるように変更。
	・仮引数タイプに "var" などの特殊仮引数の文字列が使用できるように修整。
		strcmp() 関数で文字列比較を行うので、非常に低速。非推奨。
	
2009 08/19 (Wed)
	・caller 型を追加。"call" メソッドで呼び出しが可能。
		配列の添字を関数形式の呼び出しにしようかと思ったが、参照渡しの問題で
		できなかった。
		@ f() という関数呼び出しが、call 命令の引数の中にあると、参照渡しと誤認される。
		@→ 後に実装した。 (2011.07.30)
	
2009 09/05 (Sat)
	・特殊仮引数 any を追加。型は不定、可能なら参照渡し。文字列表記は "any"。
		引数タイプ var と同じ形式で prmstack に積まれる。
	・arginfo に ARGINFOID_BYREF (参照渡し引数か) を追加。
	
2009 10/18 (Sun)
	・ジャンプ先を StDest 構造体にして、管理しやすくした(？)。
	・code_skipprm() が飛ばしすぎていたバグを修正した。
	・labelOf() を追加した。
		ラベルか、ユーザ定義コマンドが指すラベルを返す関数コマンド。
	・可変長引数を表す文字列として、"flex" だけでなく "..." を使えるようにした。
	・any で参照渡しを許可すると、変数から始まる式を渡せないバグを発見。
		検討中。
		@→ 対応した。 (2012.05.22)
	
2010 05/22 (Sat)
	・call_byref (byref) キーワードを追加した。
		@ コードが [ call_byref, 変数, operator != ] になっていたら参照渡しであることがわかる。
	・any を既定で値渡しにした。
		byref(var) で引数に与えられている場合のみ、参照渡しする。
	・deffid を defid に改名し、すべてのコマンドの id をとれるようにした。
		ただし、call や caller の対象となるのは、依然として TYPE_MODCMD のみ。
	・コマンド呼び出し機能を追加した。ほとんど関係ないが。
		callcs, callcf
		非常に tricky。コードの先読み情報を書き換えることで、ランタイムに命令・関数を呼び出させる。
		実はランタイムでも continue 命令の実装でこの方法が使われている。
	
2011.07.29 (Fri)
	・local 引数を暫定的に実装した。
		@ prmstack 的には array として (PVal* で) 積まれる。
		@ 本当は PVal 実体で積まれるが、それでは正常に解放ができない。
		@ 故に、仮宣言で "local" と指定して、deffunc では array と書く必要がある。
		@	依然、deffunc で local は使えない。
		@→ 翌日撤回
	・CArgInfo の、値渡しに使った内部変数(PVal*)が解放(delete)されていなかったバグを修正した。
	
2011.07.30 (Sat)
	・local 引数を実装した。
		@ 引数列の最後にしか指定できない。
		@	ローカル変数の領域を確保した後、prmstack のバッファを固定する。
		@	prmstack が移動してしまうと、ローカル変数の持つデータが破棄できなくなるため。
		@	CPrmInfo は、「個数 (cntLocal)」で記憶している。仮引数列に PRM_TYPE_LOCAL は含まれない。
		@ prmstack に PVal 型として積まれ、それへのポインタを CArgData が持つ。
		@	PVal_init(), PVal_free() は CArgData が行う。
	・caller 型の関数形式呼び出しを実装した。
		@ 以前これを却下した時の問題点(*)は、既に、byref の導入によって解消されていた。
		@ 単体で、かつ右辺値参照(ArrayObjectRead)のときのみ呼び出しを行う。
		@ 配列なら要素値を返す。
		@ (*): f を caller 型とすると、call コマンドの引数に f(...) というのがあったら、
		@	あくまで添字付き配列なので、参照渡しと判断されていた。
	・caller 型で、格納処理を行えるようにした。
		右辺の値を caller 型に型変換して代入する。
		@ いちいち caller() と書くのは面倒なので。
		@ 格納処理で連続代入ができるのも var_assoc 開発のおかげ。
		
2011.09.29 (Thu)
	・ModOp_Init, ModOp_Register を試験的に実装。
		@ struct 型への演算関数の登録と、指定関数の実行。ただし += のみ。
	
2011.09.30 (Fri)
	・CPrmStk で、外部の静的なバッファを利用できるようにした。
		@ 未使用。
	・struct の全演算関数と newmod, delmod を override するようにした。
		@ 演算関数の登録が未実装。
	・struct を参照カウンタで管理するようにした。
		@remain: プログラム終了時に解体したインスタンスで dtor を呼ぶと落ちる。
		
2011.10.01 (Sat)
	・(続き)
		@ 参照カウンタがちゃんと 0 になるかどうか確かめるのに時間が掛かる。
	
2011.10.02 (Sun)
	・(完了) struct を参照カウンタで管理するようにした。
	・struct で、演算関数を登録・実行できるようにした。
		@ a + b → func( a, b ) # func は a のクラスの OpId_Add の登録関数
	・struct を他の組み込み型に型変換できるようにした。
		@ 型変換関数として登録された関数を呼び出す。
		
2011.10.03 (Mon)
	・dupmod コマンドを追加した。
		dupmod self, x	// x を self の複製にする
		OpId_Dup という特殊な ID で登録された命令を呼び出す。
	
2012.01.02 (Mon)
	・STRUCTDAT から CPrmInfo を生成する処理を cmd_sub に外出しした。
		CCaller::setJumpDest( STRUCTDAT ) の中にあったが、実際は汎用的な処理なので、不適切だった。
		ラベルと同じく CreatePrmInfo() から取得できるようにした。
	・引数束縛関数 argbind() を追加した。ただし、束縛関数は束縛できない。
		行き先と引数(の一部)のみ与えられた CCaller と、残りの引数リストを保持して、
			束縛関数を表現するクラス CBound を作成した。
			現在は、生成された CBound は最後に一括解放するようになっているが、内部リークはまずいので、
				後で参照カウンタ方式に切り替えたい。
				@ 切り替えた。 (2012.01.03)
		行き先(Dest)の一つとして「束縛関数(Bound)」を追加し、StDest は束縛関数を示せるようにした。
			StDest::bound (union)
		そのため、caller は束縛関数を所持できるようになった。逆に、スクリプト側から束縛関数を触るには
			caller 値を用いるしかない。実際、argbind は生成した束縛関数を持つ caller を返す。
		呼び出し情報クラス CCall はラベルだけでなく束縛関数へのポインタ(mBound)も所持するようにし、
			呼び出し時にそれが非NULLであれば、ラベルではなくこれの呼び出しを優先するとした。
				「呼び出し先」を示すのに2つのメンバを用いるのは不自然なので、ここも StDest にすべき。
			束縛関数の呼び出し(CBound::call)は、束縛引数と余剰引数(束縛関数に与えられた引数)を組み合わせて
			被束縛関数を呼び出す、という手順で行われる。
			自然に考えて、被束縛関数として束縛関数を指定することで、段階的に束縛を行うようなことが
			できるはずだが、現状の CPrmInfo は束縛関数に対応していないため不可能となっている。
			
2012.01.03 (Tue)
	・caller 型を functor 型に改名した。
		また、各要素を struct StCaller { StDest } ではなく CFunctor = functor_t にした。
		各要素は placement-new で構築する。
			配列拡張をするときは、単純にメモリコピーで移動させればよい。placement-new のメリットである。
		破棄するときは各要素に placement-delete (というかデストラクタ呼び出し) を行う。
	・StDest を CFunctor クラスに変更した。
		メンバは依然として同じ。いくつかのメソッドを持つ。
		CCall は label, bound ではなく CFunctor を持つようにした。
		基本的に、関数の種類による違いは CFunctor のメソッドが吸収する。
			そのためメソッドが switch だらけである。美しくない。
	・CBound を参照カウンタ方式で管理するようにした。
		終了時にインスタンスを一括に除去するのはやめた。
	・未宣言ラベル関数の仮引数リストを、未指定(NULL)ではなく可変長引数とすることにした。
		@ CPrmInfo::undefinedFunc を用いる。
		@ これにより「仮引数がない」という状況が消滅したので、自動的に
		@	「仮引数がないときは参照渡し引数を変数クローンで受け取る」という仕様も消滅した。
		@ 他にもいくつか「仮引数がないとき」専用の処理があったが、どれもいらなさそう……。
		
2012.01.04 (Wed)
	・byref を ( call_byref || x ) の形にした。
	・不束縛引数を明示する nobind 引数を使用できるようにした。
		引数に nobind を指定した部分は束縛されず、残引数に入れられる。
		nobind( x ) とすると、x の値が小さいものから順に、残引数の前の方になる。
			( int x: 優先値 )
			イメージ的には 0, 1, 2, ... 。
		@ex: 
			被束縛関数: func( a, b, c, ... )
			束縛関数:   f = argbind( func, [ a: VALUE, b: nobind 0, c: nobind 2, ...[0]: nobind 1, ...[1]: nobind 3 ] );
						f = argbind( func, VALUE, nobind 0, nobind 2, nobind 1, nobind 3 );	// 実際のスクリプト
				残引数: f( p, q, r, s, ... )
				解消後: → func( VALUE, p, r, q, s, ... )
				引数番号の写像 (mpPrmIdxAssoc):
					[ 1, 3, 2, 4 ]
					// 意味: (0, 1, 2, 3) 番目の残引数は、被束縛関数の (1, 3, 2, 4) 番目の引数にそれぞれ対応する
		@impl:
		@ 束縛関数が持つ、束縛された引数と、それを呼び出す時に与えられた余剰引数を組み合わせて1本にし、
		@ それを被束縛関数に渡す。
		@	(ex): func(x, y); argbind( func, a )(b) → func( a, b )
		@words:
		@ 簡単な用語集みたいなものを一応書いておく。コメントでちらっと出てくる。
		@	(関数を) 引数束縛/Bind (parameter) [サ変名詞]
		@		関数の一部の引数に具体的な値を代入して、新たな関数[束縛関数]を得ること。
		@		部分適用ともいう。
		@	(束縛関数を) 束縛解除/Unbind [サ変名詞]
		@		束縛関数から、被束縛関数を得ること。
		@	束縛引数/Bound Arguments
		@		引数束縛するときに与えられた実引数。
		@		( つまり argbind() の実引数 )
		@	余剰引数/Remain Argument
		@		束縛関数に与えられた実引数。
		@		束縛関数の実引数。
		@	残引数/Remain Parameter
		@		束縛関数の仮引数。
		@		不束縛引数を (優先順位付けして) 並べることで得られる。
		@	束縛関数/Bound Function
		@		関数を引数束縛して得られる関数。
		@		これを呼び出すと、束縛引数と余剰引数を組み合わせて、被束縛関数の呼び出しを行う。
		@	被束縛関数
		@		束縛関数に対して、それが引数束縛される前にあった関数のこと。
	・double 引数に int 型の値を渡すと型不一致エラーになるバグを修正した。
		@  CCaller::setArgNext に変換コードを付け加えて対応した。
		@ 本来はどこで変換すればいいのかよくわからない。
	・ストリーム呼び出しオブジェクト(CStreamCaller)を追加した。
		@ functor が保持できる値の1つとして登録されている。
		@ 「引数ストリーム呼び出し」機能のリメイク。
		@	それとは違って、何度でも呼び出しを行うことができる。
		@	また、マルチプルインスタンスになったのも大きい。
		@ 実装的には、call 呼び出しの引数を追加する処理をスクリプトから制御できるようにしたもの、という扱い。
		@ 引数は何度でも追加できる。可変長引数の関数を呼び出すのに便利、かもしれない。
		@ また、呼び出すときに与えた引数はその場限りなので、実質、前方からの束縛に等しい。
	
2012.01.05 (Thu)
	・自作関数クラス CMyFunc を追加した。
		プラグインが自作した中間コードと、それが受け取る仮引数 CPrmInfo から成る。
		@ 束縛関数 CBound, ストリーム呼び出し CStreamCalling と同様。
	・関数 funcexpr() を追加した。
		与引数式を返却する自作関数を生成し、返却する。
		@ 現状、引数はとれない。
		@ funcexpr( expr ) → MyFunc() { return expr }
	・もし funcexpr() に引数を取れる関数を生成させる場合、
		その引数を prmstack に乗せると、呼び出し側の構造体パラメータが参照できなくなるので、
		引数式が構造体パラメータを持つと、見た目と異なる動作をしてしまうことになる。
			( func( x ) {  func(y) { x + y }  } )	# 内部の関数の実行時に x が参照できない、みたいな
		そのため、引数式の構造体パラメータを展開するようにしようとしていた。
			しかし、コードで変数要素 var 引数を再現するのは不可能である。と、困った。
			( 変数に APTR 値を与えられる場合。実引数が変数の高次元要素なら aptr と添字が食い違う。 )
		@ex: array x → x に与えられた PVal* の TYPE_VAR として配置。
		@ 構造体パラメータ: TYPE_STRUCT であるコード、則ち引数やメンバ変数のこと。
		→ いや、APTR を添字に分解すればいい [ すぐに実装した ]。
		@ 実際は、添字の評価をやり直す分、等価な処理ではなくなる。
		@	例えば、添字の評価が副作用を伴う場合、それは2回行われることになり、バグを引き起こす。
		@ (翌日に仕様の再変更がある)

2012.01.06 (Fri)
	・IFunctorEx クラスを追加した。
		束縛関数やストリーム呼び出しオブジェクトなど、特殊な関数子は、これの派生クラスとして実装するようにした。
		CFunctor は、bound_t などではなく IFunctorEx* typedef exfunctor_t を保持するようにした。
		また、CBound や CStreamCalling が別個に持っていた参照カウンタ機構を、IFunctorEx で実装した。
		CFunctor は「ラベル関数」「ユーザ定義関数」「特殊関数子 (exfunctor_t)」の3つのみを持つため、
		特殊関数子を追加しても変更する必要はなくなった。
	・call_prmof_(N) キーワードを追加した。
		ただし、マクロ __p0, __p1, __p2, ... の形で利用する。
		funcexpr() の引数式がこれを含む場合、生成される関数は仮引数を持つ。
		また、call_prmof_(N) は、実行時は prmstack の N 番目にある any (var|array) 引数を参照する
		コード「call_argv( N )」として中間コードが生成される。
		引数エイリアス(TYPE_STRUCT)としてコードに登録される。
		@ 仮引数は全て any 引数扱いである。
	・funcexpr() が、局所外部の環境を保存できるようにした。つまり、クロージャ生成になった。
		例えば、ある関数 fO の中で funcexpr() を行い関数 fL を得るとき、funcexpr() の引数式の中に fO の
		引数エイリアスを含めることができる。引数エイリアスは「prmstack の左から offset [byte] 目にあるデータ」
		というように参照するので、fL を実行して prmstack が変わってしまったら、f の引数エイリアスが f の
		引数を指さなくなってしまう。
		
		具体的に識別子を与えてノートを進める。
		
			#deffunc fO var a
				fL =  funcexpr( a + __p0 )
				return
				
			r = fL(3)
				
		fO を呼ぶとき prmstack = [ var(a) ]
		fL を呼ぶとき prmstack = [ int(3) ]
		引数エイリアス a は (TYPE_STRUCT, STRUCTPRM[ offset = 0 ]) である (これを TYPE_STRUCT[ 0 ]と表記する)。
		fL の中間コードは以下の通り:
			{ return, TYPE_STRUCT[0]: a, TYPE_STRUCT[0]: __p0, operator + }
		a をそのままコピーした場合、fL の実行時に、a が a に与えられた変数を参照しないのは明白。
		そこで、fL を呼び出すときは、
			「実引数の後ろに fO の引数列を付け加える」とし、
		a などはそれを参照するような形で、中間コードに書き加えるようにした。
		つまり、fL の中間コードと prmstack を以下のようにする：
			{
				return,
				TYPE_STRUCT[ 1 ]: a,
				TYPE_STRUCT[ 0 ]: __p0,
				operator +
			}
			prmstack = [ int(3),  var(a) ]
		また、ユーザ定義関数に与えられた実引数 prmstack は、関数を抜けると破棄されるので、CMyFunc の中に保存する (mpArgCloser) 。
		local 引数は mpArgCloser に変数複製して与え、式の中間コードでは、それへの array 参照として扱う。
		
		ただし、定数値である int, str や、中間コードで直接表現できる array などは、その実体を中間コードに書き込めばよいので、そうする。
		
		TYPE_STRUCT を中間コードに書き込む際、式 &ctx->mem_minfo[val] が自作の STRUCTPRM へのポインタを指すような値 val をコードに指定する。
		このとき、参照する STRUCTPRM へのポインタと ctx->mem_minfo の差(バイト数)が、sizeof(STRUCTPRM) の倍数でなければならないことに注意。
		余りが出るなら、STRUCTPRM の前に詰め物をするなどして揃える。
		引数値の、prmstack からのオフセット値は、fL の仮引数の数が確定するとき、関数生成の直前までわからないので、
		中間コード生成時は一時的な値で put しておいて、最後に書き換える (このとき自作 STRUCTPRM を生成)。
		@ 解説文が散漫。処理内容が複雑すぎて、今後も把握しておける自信がない。
		@	外部引数エイリアスが TYPE_STRUCT でなければならないのは、左辺値として参照できるようにするため。
		
2012.01.07 (Sat)
	・funcexpr() の引数式に含まれる funcexpr() の中間コードを、直接複写するようにした。
		複写するときの工夫 (TYPE_STRUCT の展開や仮引数プレースホルダーなど) は、
		その関数を実行したときに処理されるため。
	・defid と deffid の混同によるバグを修正した。
	・モジュール型(struct)の掠奪に関する機能を、拡張ヘッダ call_modcls.as に分割した。
	・funcexpr() を実行した時に「タイプの初期化に失敗しました」という謎のエラーが出てやる気減衰。
		@ どれのことか分からない。 (2012.09.16)
	
2012.09.16
	・まとまってなかったので、ここのログを参考に、いくつかのクラスにコメントを加えた。
	・残引数の順番を正しく処理できるようにした。
		@ 優先度付きキュー(priority_queue)に与える順序が "<" であることを勘違いしていた。
		@	順序 < は、左辺が“小さい”(= 優先されない)時に true を返すので、「左辺が優先される」の逆の条件を記述する必要があった。
	・funcexpr() で、最後の return を2つ挿入するようにした。
		@ そうでないと、return の引数を取り出すときにバッファオーバーフローが起きる。
		
	・modcls に関するドキュメントを作った。
		@ ex16_modcls.hsp
	・modcls_init, modcls_term の冗長な実行を無効になるようにした。
	・「乗っ取られた struct 型」のことは modcls ではなく modinst 型と呼ぶことにした。
		@ 「モジュールクラス」を扱う型を modcls にしたいため。
		@ また、clhsp でも modinst だったので。
		@ 依然として、この機能全体を指して modcls ということがある。
	・modinst 型の Copy on Write をやめた。
		@ += などの破壊的な処理でも、左辺の参照カウンタが 2 以上なら、
		@	他の参照に影響が出ないように、複製と取り替えてから処理をしていた。
	・modinst 型の参照が等しいか否かを判定する関数 modinst_identify を追加した。
	・cmd_modcls が大きくなりすぎたので、
			cmd_modcls, modcls_FlexValue, vt_structWrap
		の3モジュール(6ファイル)に分割した。
		グローバル変数は名前空間 ModCls に閉じ込めて、この3つの間でだけ使用する。
		
2012.09.17
	・いたるところに const をつけたが、まだまだである。
	・CCall で、prmstack を、呼び出し直前に1度だけ作って、デストラクタで破棄するようにした。
		@ 呼び出し直前に作って、その後すぐに破棄していた。
	・CCoRoutine を実装した。
		@ ただし基本関数子に限る。
		@ 根本的には、CCaller を何回かに分けて呼び出すだけ。
		@ co_yield で、newlab *, 1 を用いて return の次の位置を得る。
		@	return に返値を指定できないので、call_retval を用いる。
		@	また、実行中にコルーチンにアクセスできないので、プラグイン側の静的変数にHSP側の静的変数を与え、
		@	そして後者を newlab して、コルーチンの呼び出し終了直後に前者を経由で後者の値を参照する、という仕様にした。
		@	初めから CCoRoutine の静的メンバに PVal を1つ作っておけばいいけれど、破棄のタイミングが面倒なのでやめた。
	・返値を複製することなく転送できるようにした (CCall::setRetValTransmit)。
		@ 特殊関数子は、それの呼び出しの中でさらに実体関数 (Bound なら被束縛関数、等) を
		@	呼んでいることが多いため。後者の返値を、前者の返値として扱うための処理。
	
2012.09.18
	・modinst 型の一時オブジェクトがスタックに積まれても大丈夫なようにした。
		「スタックに所有されている」状態を示すメンバ FlexValue_TmpFlag を追加し、
		スタックに値が push される前に、それを立てるとともに AddRef する (FlexValue_AddRefTmp)。
		
		スタックに値が push されるのは、以下の3通りの場合 (*)：
			1. 関数(システム変数)が modinst 型の値を返却するとき
				@ ユーザ定義関数や、組み込みのコマンドからは返却されない。
			2. 二項演算の返値になるとき
				@ HspVarProc[HSPVAR_FLAG_STRUCT]::**I()
			@ 他のプラグインのコマンドが FlexValue を返却すると、フラグを立て損ねる。
			@	それ以外は call プラグインの側が処理できる。
		スタックから値が降ろされるのは以下の3通りの場合しかないので (*)：
			1. 二項演算の演算数になるとき
				@ 左辺になる場合、mpval に代入して使用される。
				@	演算関数に与えられる。
				@ 右辺になる場合、(ptr, flag) の組として扱われる。
				@	型変換されるか、演算関数に与えられる。
			2. 二項演算の右辺で、型変換されるとき
				@ HspVarProc[HSPVAR_FLAG_STRUCT]::CnvCustom
			3. code_get() [hsp3code.cpp] の返値となるとき
				mpval に代入される。
		次の3通りのときに「スタックに所有されている」フラグを減らせばよい：
			1. mpval に代入されるとき
			2. 演算関数の右辺に使われたとき
			3. CnvCustom されたとき
		これで安全に運用できる、はず。
		@ すべて、標準のランタイム [hsp3.exe] における話。
	・newmod, dupmod を関数形式でも使えるようにした。
	・thismod を右辺値として参照する modcls_thismod を追加した。
		@ modcls と関係ない。
	・組み込みの str, double, int を、それぞれの型タイプ値を返却するシステム変数としても使えるようにした。
		@ TYPE_INTFUNC の reffunc をラップし、括弧が後続しないときの処理をジャックした。
		@ HSP3TYPEINFO が type を添字とする固定長配列であることを前提としている。
		@→ 組み込み関数の処理速度に影響が出るのでやめた。 (2012.09.21)
		@	デバッグ時にのみ動く WrapCall とは異なる。
	
2012.09.19 (Wed)
	・「modnew Modcls(...)」の書式でインスタンスを生成できる modnew を追加した。
		@ 実体は「newmod -」に置き換えられるマクロ。つまり newmod - Modcls(...) 。
		@	このとき、newmod はシステム変数として処理される。そこで、コードを読み込んで
		@	関数のときと同じような処理を行うことができる。最後の - は単に読み飛ばす。
		@ なお、命令形式で newmod と同じように使用することができる。
		@	第一引数は変数をとるが、それが「- (式)」則ち内部的に「(式) -1 *」の形式であれば、
		@	その単項マイナス演算子を無視する、という処理を書き加えたため。
	・特殊関数子として CModClsCtor を追加した。モジュールクラスの構築して返却する。
		@ ModCls_Init を使っていないと生成できない。
		@ ↓の modcls_identity, modinst_cls によって生成される。
		@	識別オブジェクトを返却するなら、newmod できるだろうという考えで、
		@	このクラスを作成した。各モジュールクラスに対してユニークに生成される。
	・nullmod に対する二項演算はすべて nullmod で閉じ、
		比較は nullmod == nullmod, nullmod < (not-nullmod) とした。
		また、nullmod を他の型に型変換できるようにした。
			{ label: nullptr, str: "", double: 0.0, int: 0 }
		@ nullmod + (something) は nullmod を返却する。
		@	もちろん (something) + nullmod は something に応じて演算が行われる。
		@ nullmod である変数に += などの代入操作をしても、あらゆる副作用を生じない。
		@ nullmod は常にインスタンスより「小さい」ものとする。
		@	比較に限り、右辺が nullmod である場合にも nullmod 固有の処理を行う。
	・modcls_identity, modinst_cls を追加した。
		modcls_identity: モジュールクラスに固有のオブジェクトを取得する。
		modinst_cls: インスタンスのクラスに固有のオブジェクトを取得する。
		@ ↑の CModClsCtor の functor オブジェクトが返される。
	・modcls_name, modinst_clsname を追加した。
		モジュールクラスの名前を文字列で取得する。
	・functor 関数の、ユーザ定義コマンドに対しては defid として働くという謎仕様を削除した。
		@ いつからあったのか不明。
	・modinst でメソッド処理をできるようにした。
		特殊関数 OpId_Method (メソッド分散関数; method dispatcher) を追加した。
		分散関数は thismod, str のみを受け取り、functor 的な値を返却する。
		そして、(thismod と)残りの引数を用いて、返却された値を call する。
		@ method_replace は必要としない。むしろ使うな。
		@ メソッド名と関数オブジェクトを対応させる assoc を登録すればよいのに。
		@	assoc と連携することになったらこの仕様が邪魔になるかもしれない。
	
2012.09.20 (Thu)
	・サンプルをテストコードとして機能するようにしようとした。
		@ ドキュメントとしての機能が低下する。
	・method で、this の変数を最初の引数として扱うようにした。
		@ メソッドによるラベルの仮引数宣言に際し、自動的に PRM_TYPE_VAR ("var") を先頭に追加する。
		@ 呼び出しの際に、自動的に引数の先頭に this 変数を追加する。
		@	先頭に this を受け取らないラベルやユーザ定義コマンドをメソッドとして用いることはできない。
		@ それまで、メソッドの this 変数は、CCall::CArgData が引数とは別に管理し、
		@	prmstack の先頭に var として配置していた。
	・functor の添字に、特別なコマンド call_nocall を指定した場合、
		呼び出しを行わず、その変数の fucntor 値そのものを返却するようにした。
		@ 「array/local の連想配列型変数を添字なしで右辺値として参照するとシステムエラーが生じる」
		@	というHSPのバグに対応するため。
	・functor の master を使用しないようにした。
		@ 添字から呼び出した後、返値の ptr, type を保存していた (値自体は保存しない)。
		@	特に有用性が見当たらなかった。なぜこんな仕様だったのか。
		@	これにより dup クローンが正常に動くようになった。
	
2012.09.21 (Fri)
	・modinst のデストラクタを呼ぶ際は、mpval を値ごと保存するようにした。
		@ 変わってしまうと困るかもしれない。
		@ このとき、mpval を保存する場所としてデストラクタ呼び出しの caller の引数を使う。
		@	新たにコーディングするのは面倒なので。
		@	このために、デストラクタの CPrmInfo を作る際は、可変長引数であるということにした。
		@	また酷い仕様を作ってしまった。
	・modcls のメソッドで、実行するために返却されたメソッドの第一引数が modvar でない場合も、
		modvar を受け取れる var, any, struct なら、thismod を与えることにした。
		@ modvar でない場合は、thismod が使えないことに注意すべし。
	・label, str, double, int 以外の型タイプ値も、仮引数タイプとして認めるようにした。
		@ 実引数を受け取るに際し、その型の値でなければ型不一致エラーを出す。
		@ prmstack には、any や var と同じく変数参照が積まれる。
	・any 引数に値を modvar として与えることを指示する bythismod を作ろうとしたが、
		prmstack を生成する時点までそれが thismod 扱いであることを記憶するのが面倒なでやめた。
		@ ラベル関数に thismod を与えることができるべきである。
	・CArgData の、PVal*, APTR の配列(std::vector)を、値で持つようにした。
		@ new する必要がどこにもないため。
		@	現行のコードを修正するのは面倒なので、それへのポインタ経由でアクセスする。
	
2012.09.22 (Sat)
	・CPrmStk を生成するに際し、予め必要なサイズをきっちり計算するようにした。
		@ それまではだいたいのあたりを付けて、必要になったら拡張する、というテキトー仕様だった。
		@	( argc * sizeof(MPVarData) を予め確保しておく )
		@ prmstack は呼び出しの直前に生成されるため、可変長引数だろうがなんだろうが
		@	実引数の数は完全に確定しているため、拡張可能である必要がない。
	・CArgData で、引数や local の数を予め指定し、それらを保持する配列を自動拡張しなくて済むようにした。
		@ CCall を setFunctor (呼び出し関数の設定) をした時点で、それの仮引数情報から
		@	必要になるであろう引数や local の数を取得し、reserve する。
		@ 当然ながら、可変長引数の部分は reserve できない。
	・CPrmStk からバッファ管理機能を排除し、CPrmStkCreator に改名した。
		また、prmstack 生成処理を global 関数 から CCall の static メンバ関数に変更した。
		@ バッファ管理は CCall が行うようにした。
		@	↑の reserve によって、バッファ拡張機能が不要になり、
		@	alloc/free のみになったので、あえてクラスを使うまでもなくなった。
		@ CPrmStkCreator は、prmstack を生成する際にのみ使用する、
		@	型の処理などを行うためのインターフェースとなった。
		@ 外部バッファを prmstack として使用することはできなくなった。
		@	そもそもこの機能は使わなかったし、使う宛もない。
	
2012.09.23 (Sun)
	・統合プラグイン obsidian に初期参加した。
	・functor_argc, functor_isFlex を追加した。
	・call_getlocal() を追加した。ローカル変数の値を取得する。
		call_valof と実装的に等しい。
	・funcexpr で、複数の式を実行できるようにした。
		最後以外の式は、順次ローカル変数に保存され、それ以降の式から値として参照することができる (__vN というマクロ、実体は call_getLocal() 関数を用いる)。
		そのため、funcexpr の実体であるラベル関数は仮引数宣言を持つ。
		@ funcexpr( a, b, c, ..., r )
		@	→ { __v0 = a : __v1 = b : __v2 = c : ... : return r }
		@ これにより、複雑な式を分割して記述できる。
		@	f = funcexpr( assign(a, __p0),  funcexpr( a + __p0 ) )
		@	⇔ p => (q => p + q)
	
2012.09.26 (Wed)
	・delmod によって、mpval や返却用変数などからもそのインスタンスを取り除くようにした。
	
2014.02.13 (Thu)
	・複数引数の funcexpr にあったちょっとしたバグを修正した。
		コード複写のループの終了条件がテキトーだった
	・DefId → AxCmd に名前を変更した。
		これが表している、「HSPの中間コード(ax形式)におけるコード・セグメントの1単位」
		というニュアンスにやや近づいた。
		DeffId (ユーザ定義コマンドの値、すなわち TYPE_MODCMD の code 値) と紛らわしかった。
		実際、AxCmd であるべきところを DeffId と表記されている部分が多数あった。
	・code_getaxcmd で、引数式の最初だけ見て後は読み飛ばしていたのを、
		式が2つ以上の字句からなっていたらエラーを出すようにした。
		@before: exflg &= ~EXFLG_2; code_skipprm();

2014.09.13 (Sat)
	・CMyFunc → CLambda に変更した。

2014.09.17 (Wed)
	・functor が、ラベル関数、ユーザ定義コマンド関数と特殊関数子を分けるという、
		中途半端な方式だったのをやめて、すべてインターフェース IFunctor で表現することにした。
		(どちらも代数的データ型の実装手段。)
		ラベル関数、ユーザ定義コマンド関数は、動的メモリ確保を要する分無駄に重くなるが (今まではそれが理由で分離していた)、
		仮引数はキャッシュから読むし、それらの functor を書き換える手段はないので、インスタンス共有による弊害はない。
	・functor の参照カウンタ管理のために Managed<> を使うようにした。
		dynamic_cast<> のような機能がなくてしょぼい。標準のスマートポインタの技法を学ぶべき。
	・可変長引数を、prmstack に any をたくさん乗っけるのではなく、vector 型の値1つを使うことにした。
		@ prmstk を再確保してメモリ位置が変わると、local 変数が危ないことになるので。
		var_vector.hpi を内部的に参照するが、vector 型は提供しない。
		両方使う場合、あるいは apply などのコマンドを使う場合には obsidian を使う。
		@ 変数要素参照をどうするのだ？

2014.09.18 (Thu)
	・PrmStk 形式のデータをより高度に取り扱うクラス、CPrmStk を作った。
		バッファの確保と解放、local 変数の解体と確保、値ポインタ (PDAT*, vartype_t) を元に追加すべきデータに処理を振り分ける関数(pushArgByVal)など。
	・文字列データを PrmStk のためにコピーするようにした。
	・PrmStk の offset 値を、すべて仮引数リスト(CPrmInfo)の生成時に計算しておくようにした。
	・ラムダ関数の「キャプチャ引数」を PrmType_Capture にした。
		背景：ラムダ関数を生成する際に、式中に var, local 引数の値があれば、それらの値を保存しておく。
		var 引数はコードとして展開できないため、ラムダ関数を呼ぶ時点で、同じ値を持つ var 引数を引数リストの中に入れておき、それを参照することで、等価なコード実行を実現する。
		local 引数は消滅してしまう可能性が高いので、保存して、ラムダ関数からは保存された変数の方を参照する。
		これらの値を参照する引数を「キャプチャ引数」と呼び、呼び出し直前に PrmStk に積まれていた。
		しかしこれらの引数は実引数から受け取るものではなく、引数が多すぎる場合にエラーを吐けなくなってしまうため、「実引数から受け取る仮引数」だけのリストを作っておく必要があった。
		変更点：キャプチャ引数は PrmType_Var/PrmType_Array ではなく PrmType_Capture 仮引数として扱うことにした。
		これは、local 引数と同様に、実引数から値を受け取らない。参照する際は、aptr が有効なら var 引数と、無効値なら array 引数と等価に参照する。
	・拡張型を含め、int 以外の型による仮引数を省略できないようにした。
		int は依然として既定値 0 になる。
	・ユーザ定義コマンドによる関数を、(その本体を指すラベルからなる)ラベル関数に内部的に置き換えるようにした。
	・CFuncCaller → Invoker に変更した。
		IFunctor ではなくした。結局、CCall と CCaller を合体させたものになった。






























＠Developing
＠Wish
・functor の label, axcmd への型変換
・knowbug との連繋
・ラベル関数以外もコルーチンにできるようにしたい。

・vector.hpi と統合
	実引数リストの vector 扱い。
	引数の完全転送、マージング
	
	統合するなら独立性を高く設計する技術がほしい。
	
	内部的に CVector を使う (vector.hpi と初めから統合していることにする) という仕様でもいい気がする。両方必要なら obsidian.hpi を使ってね (assoc もついてくるけど)。
	→ APTR の扱いが異なるので困る。

-----
・省略値を独自で設定できるようにしたい。CPrmInfo を使えばできるが、(HSPから) どのように指定するのか。
	functor FuncWithDefaultArg (→ 省略値を含む PrmStk を持つ) を噛ませる
	pushArgByDefault をオーバーライドした CPrmStk を持つ
・new は効率が悪い。なるべく hspmalloc を使う。
・呼び出しのたびに Push/Pop するのは重いかも。
・prmstack を継承する呼び出し処理
・exinfo->code_next を書き換えると：
	int type_bak, val_bak, exflg_bak; void(*code_next_impl)(); void code_next_tracked() { *type = type_bak; *val = val_bak; *exinfo->npexflg = exflg_bak; exinfo->code_next = code_next_impl; }
	自然にバックトラッキング処理を行うことができる。
	もちろん code_next() を exinfo を介さずに呼ぶ関数 (ほぼ全部) は使えない。
	ポインタの書き換え、最適化できない関数の呼び出しが多く、実行効率が悪い。
	code_backtrack( int type_bak, int val_bak, int exflg_bak ) { auto code_next_bak = exinfo->code_next; exinfo->code_next = [=] { *type = type_bak; *val = val_bak; *exinfo->npexflg = exflg_bak; exinfo->code_next = code_next_bak; }; }
・明示 any 引数は省略不可能？ (現在は省略値 int(0))

// uedai 2008 - 2014.







-----------------------------------------------------------------------
元：2012.09.18

(2014/09/12)
以下、すべて標準ランタイム hsp3.exe での話としておく。

解体時に解放操作を要し、なおかつ一時オブジェクトになりうる(HSPにおける意味での)「値」は、garbage collection の対象である。以下、仮にそれを obj 型と呼ぶ。

obj 型の値は追加で次の2つの要素を持つ：

1. cnt_
2. tmpCnt_

cnt_ は、それを所有するHSP変数の数を表す参照カウンタであり、同時に、tmpCnt_ は、HSPのスタックがそれを所有する数を表す参照カウンタである。両方が 0 になったとき、その値を解体する。


今回の趣旨ではないが、一応、変数の参照カウンタ cnt_ に関する詳細を述べておく。
HspVarProc::Alloc などにより変数内に直接生成される obj 値は、cnt_ = 1 になる。
HspVarProc::Free などにより変数内から直接取り除かれる obj 値は、cnt_ が1減少される。
HspVarProc::Set により変数に代入される obj 値は、cnt_ を1増加される。

値がいつも変数のみによって所有されるなら、上述の方法で問題なく garbage collection が行われる。


さて、スタックの参照カウンタ tmpCnt_ に関して述べる。
どの変数にも所有されていない値を、一時オブジェクトと呼ぶ。
値が一時オブジェクトになりうる場合、値がHSPスタック上にコピーされる際に参照カウンタの増減が行われないため、スタック上にある間に参照カウンタが 0 になったり、参照カウンタが増殖したりする現象が起こりうる。

HSPスタックを値が乗り降りする際には、その型のテンポラリ変数(一般に mpval と書く)が介される。これを監視することで、スタックからの乗り降りを監視できる、と思った。

スタックに値が push されるのは、以下の3通りの場合に限る：

1. 外部プラグインの関数(システム変数)コマンドにより、obj 型の値が返るとき。
→ mpval を介さない。

2. 二項演算が obj 型の値を返すとき (HspVarProc[obj]::**I)。
→ mpval を介す。実際には、演算関数に左辺として mpval が与えられて、それが破壊的に変更される形で返値が得られるため、mpval によって所有されている。

3. 二項演算の左辺に obj 型が与えられたとき。
→ 左辺の値をスタックに積んだ後、演算右辺式を実行する。その間、左辺の値は参照カウンタが保護されない。演算開始時に、スタックから降りて mpval に入り、演算関数が呼ばれる。通常、値は演算関数の中で破壊される。

*. 二項演算の右辺に obj 型が与えられたとき
→ 演算右辺式が完了すると、一旦それはスタックに積まれるが、直後に code_calcop() が呼ばれて、スタックから取り出される。その間、右辺の値の参照カウンタが増減することはない。その値は、必要なら型変換される (HspVarProc[obj]::CnvCustom)。そして、演算関数 (**I) に与えられる。演算関数を抜けたら、スタックを降りて消失する。

なお、特に modinst 型については、他のプラグインのコマンドが FlexValue を返却する場合、obsidian.hpi (call.hpi) の管理下にないので、参照カウンタの増減を行えない。

このそれぞれに際し、tmpCnt_ を1増やせばよい。

スタックから値が降ろされるのは以下の3通りの場合に限る：

1. 二項演算の演算数になるとき。
→ 左辺になる場合、mpval に代入されてから、演算関数に与えられる。
→ 右辺になる場合、(ptr, flag) の組として扱われる。型変換されるか、演算関数に与えられる。

2. 二項演算の右辺で、型変換される直前。
→ (HspVarProc[obj]::CnvCustom)　型変換によって返却された値は演算関数の右辺となり、その後消失するため、一時オブジェクトといえる。

3. (hsp3code.cpp)::code_get() の返値となるとき
→ mpval に代入される。その後、この code_get を呼んだプラグイン関数に制御が戻る。

以上を踏まえて、具体的な実装に関して述べる。

1. プラグインコマンドが obj 型の値を生成して返却する場合、mpval を介さずにスタックに積まれるため、tmpCnt_ = 1 としておく。

2. 

従って、次の3通りのときに tmpCnt_ を1減らせばよい。

1. mpval に代入されるとき
2. 演算関数の右辺に使われたとき
3. CnvCustom されたとき

以上、で問題ない、と思っていた時期が確かに存在した。


ここで、参照カウンタが2種類に分裂したのは、「スタックが obj 値を所有しているかどうか」というフラグとしての意味を持っている。そのため、スタックが obj 値を所有しているとき、さらに同じインスタンスをスタックに積み上げようとすると、参照カウンタ tmpCnt_ の増減が誤作動する。
具体的には、obj 値が mpval に代入されたとき、それが既にスタックに置かれているインスタンスと同一なら、それがスタックを「降りてきた」ものと誤解されて、tmpCnt_ が減る。冒頭のサンプルコードでいうと、関数 f の中でコメントされている行にて、それが発生する。

さて、どうしたものか。

(2014/09/12) 改稿
解体時に解放操作を要し、なおかつ一時オブジェクトになりうる(HSPにおける意味での)「値」は、garbage collection の対象である。以下、仮にそれを obj 型と呼ぶ。

obj 型の値は参照カウンタ cnt_ によって参照カウントされる。基本的に、これはその値を所有する(HSPの)変数の数である。


今回の趣旨ではないが、一応、変数の参照カウンタ cnt_ に関する詳細を述べておく。
HspVarProc::Alloc などにより変数内に直接生成される obj 値は、cnt_ = 1 になる。
HspVarProc::Free などにより変数内から直接取り除かれる obj 値は、cnt_ が1減少される。
HspVarProc::Set により変数に代入される obj 値は、cnt_ を1増加される。

(HSPの)変数の解体処理にぬかりはない。値がいつも変数によって所有されるなら、上述の方法で問題なく garbage collection が行われる。


さて、(HSPの)スタックに関して述べる。

どの変数にも所有されていない値を、一時オブジェクトと呼ぶ。
str 型を除き、値がスタックに置かれる際には、値のビット列が単純にコピーされて置かれる。(そのときのサイズが HspVarProc::GetSize() である……というのは脱線。)

つまり、値がスタック上にコピーされる際に、参照カウンタの増減は行えない。そのため、スタック上にある間に参照カウンタが 0 になったり、参照カウンタが増殖したりする現象が起こりうる。

スタックに obj 値が push されるのは、以下の4通りの場合に限る：

1. 外部プラグインの関数(システム変数)コマンドにより、obj 型の値が返るとき。
→ mpval を介さない。

2. 二項演算が obj 型の値を返すとき (HspVarProc[obj]::**I)。
→ mpval を介す。実際には、演算関数に左辺として mpval が与えられて、それが破壊的に変更される形で返値が得られるため、mpval によって所有されている。

3. 二項演算の左辺に obj 型が与えられたとき。
→ 左辺の値をスタックに積んだ後、演算右辺式を実行する。その間、左辺の値は参照カウンタが保護されない。演算開始時に、スタックから降りて mpval に入り、演算関数が呼ばれる。通常、値は演算関数の中で破壊される。

4. 二項演算の右辺に obj 型が与えられたとき
→ 演算右辺式が完了すると、一旦それはスタックに積まれるが、直後に code_calcop() が呼ばれて、スタックから取り出される。その間、右辺の値の参照カウンタが増減することはない。その値は、必要なら型変換される (HspVarProc[obj]::CnvCustom)。そして、演算関数 (**I) に与えられる。演算関数を抜けたら、スタックを降りて消失する。

なお、特に modinst 型については、他のプラグインのコマンドが FlexValue を返却する場合、obsidian.hpi (call.hpi) の管理下にないので、参照カウンタの増減を行えない。

スタックから obj 値が pop されるのは以下の3通りの場合に限る：

1. 二項演算の演算数になるとき。
→ 左辺になる場合、mpval に代入されてから、演算関数に与えられる。
→ 右辺になる場合、(ptr, flag) の組として扱われる。型変換されるか、演算関数に与えられる。

2. 二項演算の右辺で、型変換されるとき。
→ (HspVarProc[obj]::CnvCustom)　型変換によって返却された値は演算関数の右辺となり、その後消失するため、一時オブジェクトといえる。

3. (hsp3code.cpp)::code_get() の返値となるとき
→ mpval に代入される。その後、この code_get を呼んだプラグイン関数に制御が戻る。

以上を踏まえて、具体的な実装に関して述べる。

1. obj 型の値は、cnt_ に加えて、要素 tmpobj_ を持つ。これは、その値が一時オブジェクトであるか否かを表す。一時オブジェクトであるかぎり、その cnt_ を1多くしておく (一時オブジェクトでなくなったとき、cnt_ を1減らす)。

2. プラグインコマンドが obj 型の値を生成して返却する場合、それは一時オブジェクトである。

3. 変数に一時オブジェクトが代入・所有されたとき、それを一時オブジェクトでなくする。ただし、mpval は値の一時オブジェクト性を失わせない。

4. obj 型の演算関数では、左辺を破壊する前に、左辺の obj 値を release する。演算の結果を左辺に破壊的に書き込む (通常の演算処理)。返値が obj 型なら、mpval に所有される意味で、addref する。その後、右辺が一時オブジェクトなら、それを解体する。

5. HspVarProc[obj]::CnvCustom では、与えられた値が一時オブジェクトなら、一時オブジェクトでなくする (通常は解体される)。

6. プラグインコマンドが obj 型の一時オブジェクトを受け取った場合、すぐに次のどちらかを行う：「それをいずれかの変数に所有させる。」「それを解体する。」　なお所有させる変数を用意できないことが多いので、実装では代わりに Holder クラス(参照カウンタを増減させる)を用いることがある。その値が一時オブジェクトなら、返却するか、HSPの変数に所有させるか、解体しなければならない。

また、参照カウンタを使うが参照型ではない型の場合、以下のように変更する。

1. 
