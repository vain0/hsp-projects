
	引数付きラベル呼び出しプラグイン

・被呼び出し先(functor_t)

実体は Managed<IFunctor> 型。
呼び出し先と、引数が与えられた後の呼び出しの具体的な実行を行う。

・呼び出し手順

functor の一種の、FuncCaller を使う。
これに呼び出し先と、引数を順次設定してゆき、call を行う。
FuncCaller が内部で、与えられた functor の呼び出し処理に転送してくれる。

・FuncCaller

functor_t
prmstack
call

streamcaller に似ている。

LabelFunc:

ラベルを持つ。仮引数リストは宣言されたもの(キャッシュされる)か、未宣言仮引数である。
呼び出すときは、与えられた実引数からなる prmstk で ctx->prmstack を差し替えて、ラベルに gosub する。

Deffunc：

MODCMD ID を持つ。仮引数リストは、それの仮引数を CPrmInfo に変換したキャッシュを読み取る。
呼び出すときは、与えられた実引数からなる prmstk を使って、そのユーザ定義コマンドの先頭を指すラベルによる LabelFunc を呼ぶ。

→生成する時点でラベル関数ということにしてもいい気がしてきた

Bound：

元となる functor と、それに対するいくつかの実引数が与えられた prmstk (finalize はされていない状態)、
残りの仮引数からなる仮引数リストを持つ。
呼び出すときは、その prmstk のコピーに、与えられた実引数を加えて finalize してから、元の functor を呼ぶ。
(prmstk のコピーを実装する必要がある、問題ない)

Composite (合成関数)：

2つの functor を持つ。呼び出すときは、与えられた実引数を前者に与えて呼び出してから、その返値を実引数として、後者に与える。
この関数の返値は、2回目に呼び出した関数の返値である。

OpDist (演算分配関数)：

2つの functor と1つの演算を持つ。
仮引数リストは、その2つの functor に共通のものである。
	(仮引数リストの同値性を定義する必要がある；
	あるいは仮引数の情報を弱くして共通化する方法を与える)
呼び出すときは、与えられた実引数をそれぞれに与えて順次呼び出してから、
	local 変数はクリアする？
それらの返値を演算したものを返す。

Caster (型変換による関数)：

2つの型タイプ値と、一方の値からなる仮引数リストを持つ。
呼び出すときは、与えられた値を、他方の型に変換して、それを返す。gosub を生じない。
演算関数と同様に、HSP側でユーザ定義関数として定義すればいい。
	その中で opex の cast コマンドを使う。

Lambda：

生成したコード、キャプチャした値 (ManagedPVal[])、仮引数を持つ。	
呼び出すときは、prmsk にキャプチャ引数の仮引数と (中間計算値用の) locals を追加して、
	キャプチャ引数は PRM_TYPE_VAR, PRM_TYPE_ARRAY だが、呼び出すときに与えられるものではないので、
	仮引数リストを分けることで対応している。
	PRM_TYPE_CAPTURED などを作ればいいのでは。扱いとしては local の同類。
コードの先頭を指すラベルの関数を呼ぶ。
	finalize した後のラベルの仮引数リストとして宣言してもいいが、


メモ

call result は誰が持つ？

ラベル関数にどうしても2種類以上の仮引数が必要な場合はこんなコマンドを用意する：
	labelFunc(*label, prms...) → 仮引数付きラベル関数 (functor) を返す
・合成関数
	(f >> g)(...) = f( g(...) )
スクリプト側から関数子の種類を識別する何かは必要。

------------------------------------------------------------------------
以下、第二バージョンの仕様。

・被呼び出し先(functor)
		ラベル or ユーザ定義関数
			prmstack 差し替え
			code_call()
			
		束縛関数(bound)
			被束縛関数の呼び出し (CCaller を用いる)
			
		ストリーム呼び出し(stream)
			元の関数の呼び出し (CCaller を用いる)
			
		コルーチン(coroutine)
			元の関数の呼び出し (内部で1つの CCaller を保持し、それを繰り返し用いる)
	
・呼び出し手順
	(Call 関数参照)
	
	0. CCaller 生成
	1. 呼び出し先設定
		setFunctor
	2. 引数設定
		addArgByVal		// 外部から引数を与える
		addArgByRef
		setArgNext		// スクリプトから引数を取り出す
		setArgAll
	3. 呼び出し
		call
	4. 返値の取得
		getCallResult
		
・クラス
	CCaller
		呼び出しと、それに関する設定を行う処理をサポートするインターフェースとして活用する。
		主に、呼び出しを行う場所で、ローカル変数として生成される。
		
	CCall
		呼び出しに関する設定を所有、管理する。
		
		CCall::CArgData
			呼び出し時に持ち込む値データ { 引数, this } を所持する。
			必要なら PVal* を自作する。
			CCall の一部を独立させたもので、CCall のみが認知する。
		
		CPrmInfo
			受け付ける引数タイプの設定を所持する。
			ラベル関数とこれの組がグローバル変数に保存されている。
			また、ユーザ定義関数のSTRUCTDATをこれに変換することが出来る。
				変換には関数 CreatePrmInfo( ..., STRUCTDAT& ) を用いる。
				実際に変換を行う CCaller::setFunctor の局所静的変数に、STRUCTDAT とこれの組が保存されている。
	
--------------------------------------------------------------------------------
以下、非常に古臭い仕様

・呼び出し方法
	命令：call label, 引数1, 引数2 ...
	関数：call(label, 引数1, 引数2 ...)
	
	引数は可変長。ラベル側が受け取る引数の数は関係なし。
	
・ラベル命令の定義
	命令形式対応版
	*label
		// 処理
		return
	
	※通常と同じ。
	
	関数形式対応版
	*label
		// 処理
		call_retval 値	// ←戻り値を設定する
		return		// 戻る
	
	※call_retvalに値をセットせずreturnした場合、
	 「関数の戻り値がない」というエラーが発生する。
	　必ず一度以上 call_retval が呼ばれるような設計にすること。
	
・ラベル側
	引数をすべて受け取る必要はない。また、エイリアスを作る必要もない。
	argv() やrefarg()などの関数によって、引数にアクセスすることが可能
	である。
	
	引数は、可能なら参照渡し、不可能なら値渡しとなる。つまり、変数を
	指定した場合は var。定数を指定した場合は値渡し。型チェックは行われ
	ない。plugin側は、どんな型でも許容する。
	