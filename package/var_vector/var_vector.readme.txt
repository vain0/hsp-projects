
	var_vector (version 1.0)

【　名　称　】var_multi
【　種　別　】HSP3拡張プラグイン
【　作　者　】上大
【 取り扱い 】フリーソフトウェア
【 開発環境 】Windows XP HomeEdition SP3
【 動作確認 】Windows XP
【 サポート 】http://prograpark.ninja-web.net/

＠目次
　・概要
　・展開
　・削除
　・パッケージ
　・機能
　・ソースコード
　・著作権
　・参照

＠概要
	複数の型の値を混在させられる一次元配列、vector型を登録するHSP3専用
	の拡張プラグインです。
	詳しい使用方法は、「＠機能」を参照してください。
	
＠展開
	ダウンロードした圧縮ファイルを適当なところに解凍してください。
	他に特別な手続きは必要ありません。
	
＠削除
	本ソフトウェアが不要になった場合は、
	関係のあるファイルやフォルダを削除してください。
	「＠パッケージ」参照。
	
＠パッケージ
　　[var_multi]
　　　　┣ [src]　　　　　…… Ｃ＋＋ソースコード
　　　　┣ readme.txt　　 …… このファイル。取扱説明書。
　　　　┣ var_vector.as　…… 専用ヘッダ。
　　　　┗ var_vector.hpi …… 実行ファイル
	
＠機能
・準備
	ランタイム( 通常はhsp3.exe )とhspcmp.dllがあるフォルダに
	var_vector.hpiを、hsphelp フォルダに var_vector.hs を、
	それぞれコピーしてください。
	
・使用法
	同梱されている var_vector.as を、スクリプトの最初の方で #include
	してください。
	
		#include "var_vector.as"
	
	vector 型変数を作成するには、vector 命令を使用します。使い方は
	dim 命令とほぼ同様です。
	
		vector v1		// vector 型の変数
		vector v2, 5	// 初めから要素を5つ持つ
		
	vector は、一次元配列として振る舞います。
	
		vector v
		v(0) = 2		// 要素番号 0 の要素に値 2 を代入する
		v(1) = 3		// 代入文では、配列の自動拡張が適用される
		v(2) = 5, 7, 11	// 連続代入もできる
	//	v(2) = 5 : v(3) = 7 : v(4) = 11
	
	通常の一次元配列と異なり、vector は複数の型の値を混在させることが
	できます。
		
		vector v
		v(0) = 256		// int 型
		v(1) = "hello"	// str 型
		v(2) = 1.41		// double 型
	
	vector の各要素は、それぞれ一種の変数となっていて、これを vector
	の「内部変数」と呼びます (型が混在できるのはこのため)。
	内部変数も変数なので、配列にすることが可能です。VectorDim 命令を
	使います。添字は、vector の添字の後(2つ目以降)に書きます。
	
		vector v
		VectorDim v(0), vartype("int"), 10	// int[] の配列
		mes VectorLen(v(0))
		v(0, 1) = 1				// 内部変数 v(0) の 要素(1) に代入
		
	連続代入の挙動が、一見ややこしく見えるので注意してください。
	内部変数への添字を指定している場合は内部変数を、そうでなければ
	vector配列自体を対象として、連続代入を行います。
		
		vector v0
		v0 = 1, 2, 3			// 変数 v0 に 1, 2, 3 を代入
	//	結果、v0 は vector ではなく int 型の配列になります
		
		vector v1
		v1(0) = 1, 2, 3			// vector配列 v1 に 1, 2, 3 を代入
		
		vector v2
		v2(0, 0) = 1, 2, 3		// 内部変数 "v2(0)" に 1, 2, 3 を代入
	
	vector 型は初めから特定の値を持った状態で生成することができます。
	
		v0 = vector()				// 要素なし
		v1 = vector( 256, "hello", 1.41, vector() )
		v2 = vector_reserved( n )	// n 個の要素 (初期状態)
		v3 = vector_from_array( arr )
	
	その他、命令を用いて要素の順番を変更したり、文字列にしたりできます。
	
		v = vector( 1, 2, 3 )
		VectorReverse v				// 逆順に並べ替える
		mes VectorJoin( v, ", " )	//=> "3, 2, 1"
	
	拙作デバッグウィンドウ knowbug を使用すると、vector 型の中の値を
	表示することができます。
	
＊既知の問題
・検討中
	
・対応不可
	内部変数に対しては複合代入演算 (++, += など) ができない。
	
＠ソースコード
	[src]フォルダの内部のファイルすべてです。不要な場合は、フォルダ
	ごと削除してもかまいません。
	
	Visual C++ 2010 Express Edition を使用しています。
	バグや間違いを見つけたら、報告していただけると非常にありがたいです。
	( 「＠参照」を参照 )
	
	ソリューション var_vector のフィルタ hsphdk は、ファイルのパスが
	おかしい可能性が高いので、hspsdk フォルダのファイルに入れ替えて
	ください。
	
＠著作権
	※hspsdkの中のモノは、OpenHSPのライセンスに従ってください。
	　英語ですが……。
	
	著作権は作者である上大が持っています。プログラムは無断で転用・
	改変してもかまいません。hpi単体の場合、二次配布も許可します。
	
＠参照
	・プログラ広場
	　意見や感想、バグ報告、最新版のダウンロードなどはここで。
	　http://prograpark.ninja-web.net/
	
	・HSPTV! ( HSP本家サイト )
	　http://hsp.tv/
	
	・HSP開発wiki ( C++でのプラグイン作成講座がある )
	　http://hspdev-wiki.net/
	　→ ::SideMenu::TOPICS::プラグイン::その他::プラグイン作成ガイド
	
＠更新履歴
2014.09.15 (Mon)
	・Managed<> を使って作り直し。
	・vector への連続代入をする際に、連想配列なのに通常配列用の関数を用いていたため、
		常に PVal::len[1] = 1 という仕様により必ず自動拡張のための redim が呼ばれていて、
		なおかつ新しい長さとして 2 が指定されるため自動拡張になっていなかったバグを修正した。
	・vector は既定で長さ 0 に初期化されるようにした。
		ただしテンポラリ変数(mpval)だけは nullptr で初期化される。
		また、内部用のプレースホルダ(コマンドの返値や VectorResult の保存用)なども nullptr で初期化されるが、それらを読み込むことはないので問題ない。
		一応 VectorNull, VectorIsNull は残しておく。
	・

2014.09.13 (Sat)
	・vector の内部形式を変更した。
	・vector の一時オブジェクトが代入文の右辺に与えられて、かつその値が型変換されなかったとき、Release されないままリークしていたバグを修正した。
	・VectorReplace により内部変数の参照が複写される際に、参照カウンタを回していなかったバグを修正した。
	・反転区間に関する仕様をすべて削除した。
	・VectorReplace の仕様を変更した。
		前：よく分からない挙動
		後：引数(vector self, iBgn, iEnd, vector src)
			self の区間 [iBgn, iEnd) を src の各要素で置換する。
			例1：vectorReplace( vector(0, 1, 2, 3), 1, 3, vector("a", "b", "c") )
				→ vector(0, "a", "b", "c", 3)
	・多数のコマンドが「パラメータの値が異常です」(HSPERR_ILLEGAL_FUCNTION)のつもりで
		HSPERR_INVALID_PARAMETER を投げていたバグを修正した。

2014.09.11 (Thu)
	・関数コマンド VectorAt が無効なポインタを返却する可能性があったバグを修正した。
		添字が vector 型変数自体を参照しているとき、CVector** としてローカル変数へのポインタを返していた。

2014.09.08 (Mon)
	・knowbug の拡張型表示に対応した。ただし、今まで通り knowbug 側で vector 型の値を文字列化することもできる。

2012.11.09 (Fri)
	・関数コマンド VectorAt を追加した。右辺値に対する添字演算を行う。
	
2012.09.30 (Sun)
	・特殊な添字 VectorLast, VectorEnd を実装した。
		VectorLast は「最後の要素」則ち (要素数 - 1) を、
		VectorEnd  は「vector末尾」則ち (要素数) を、添字にしたものとして扱う。
		@ VectorLast は要素数 0 のとき添字違反とする (自動拡張は無視する)。
		@ どちらも通常の添字になりえない負数で定義されている。
	・要素挿入・除去系の命令が、第一引数をなぜか変数として受け取っていたバグを修正した。
		@ vector をとって、それに破壊的処理をする。
	
2012.09.25 (Tue)
	・内部変数を、最初に参照されるまで初期化しないようにしようかと思ったけれど、
		アクセスのコストがかさむだけで実際には利点が無さそうなのでやめた。
	・要素挿入・除去系の命令を関数としても使えるようにした。
		@ Insert, PushFront, PushBack, Remove, PopFront, PopBack
		@ スライスに命令を適用したものを返却する。
	・Insert, Remove を区間に対して適用するようにした。
		加えて、単一要素のみを挿入・除去する Insert1, Remove1 を追加した。
	
2012.09.24 (Mon)
	・要素移動系の命令が、変数が持つ vector を破壊的に処理するようにした。
		@ 命令は破壊的、関数は非破壊的、という法則に従っていなかったので。
	・Rotate の説明が間違っていたので修正した (処理は正しかった)。
	・VectorReverse の反転区間の処理が間違っていたので修正した。
		@ [a, b) ⇔ [b + 1, a + 1) なのに [b, a) として処理していた。
	・VectorSlice や VectorChain で、反転区間を使用できるようにした。
		@ 今までは null を返却していた。
	・VectorSliceOut, VectorReplace をプラグイン関数にし、反転区間に対応した。
		
2012.09.23 (Sun)
	・vector の内部バッファを size(PVal*) * 要素数(キャパシティ) ではなく
		sizeof(PVal) * 要素数(キャパシティ) もとってしまっていたバグを修正した。
	・vector の内部バッファは、最初から要素 16 個分あることにした。
		@ アロケータ(hspmalloc)の仕様上、元々そうだったが、CVector にも理解させた。
	
2012.09.22 (Sat)
	・右辺値として添字付き参照したとき、添字が要素数を超えていたら、自動拡張をせず、エラーを出すようにした。
		@ ものぐさ実装をやめた (template で対処できると分かったので)。
		@ var_assoc にも同様の処理をした。
	・内部変数が vector でない連想配列でも正しく動くようにした。
		@ 右辺値として参照するときも、標準配列・連想配列の両方に対応するように作った
		@	code_expand_index_impl_rhs を使うようにした。
		@ var_assoc にも同様の処理をした。
		
2012.09.20 (Thu)
	・vector 命令で生成されたとき、参照カウンタが 0 のままになっていたバグを修正した。
		@ え……？
	・「後見」システムを廃止した。
	・vector がHSPのスタックに積まれる際に、スタック用に参照カウンタを増やすことで、
		破棄されないように守るようにした。
		@ 詳しくは call.hpi の modcls を参照 (同じシステムの参照カウンタが導入されている)。
		@ 増やしたカウンタは、どのようにスタックから降りてもちゃんと減らされるようにしている。
	・VectorChain の第一引数が一時オブジェクトの vector だった場合、
		第二引数を取り出すに際し死亡していたバグを修正した。
		@ 第一引数に破壊的処理をする命令なので、ありえない状況だろうけど。
	・VectorClone の引数を、(dst, vec(...)) から (vec(...), dst) に変更した。
		@ dup は普通 (dst, src) だが、vector は this 的なものなので、第一引数にとるべき。
		@	というかサンプルを書いているときにこれで嵌った。
		@ また、PVal::master や support まで複写するようにした。
		@	hpimod に、そういう命令 (PVal_cloneVar) を追加した。
		
2011.07.29 (Fri)
	・knowbug との交信用の GetVectorList_t で、構造体を用いずに直接 PVal** を返すようにした。
	
2011.07.24 (Sun)
	・一時オブジェクトを、生成後、ある程度の期間は内部で保存するようにした (「後見」システム)。
		@ 式中で突然消滅してしまう可能性があるため。
		@ スタックに積まれるときに参照カウンタが増減しない問題への対処。
		@ stop が呼ばれたときにすべて解放する。
	・CVector::Compare() で HspVarProc::LtI, GtI, LtEqI, GtEqI を実装し、大小比較ができるようにした。
	・リリース (ver: 1.0)
	
2011.07.22 (Thu)
	・VectorInsert 他、要素追加命令で初期値を設定できるようにした。
	・VectorSliceOut を追加した。
	
2011.07.20 (Wed)
	・命令コマンドを追加した。
		VectorInsert(), VectorPushFront(), VectorPushBack(),
		VectorRemove(), VectorPopFront(), VectorPopBack()
	・vector の代入(Set)で、「左辺の vector を右辺の vector の全ての要素を共有するようにさせる」ようにした。
		@ ただし、左辺がテンポラリ変数ならば、いままで通り共有参照の生成を行う。
	・VectorResult(), VectorExpr() を追加した。
	
2011.07.19 (Tue)
	・内部変数 PVal* を、PValRef* とし、参照カウンタで管理するようにした。
	・要素順序操作系コマンドで、PValRef* を引き継いだ CVector* を新たに生成するようにした。
	・要素順序操作系コマンドの関数形式に対応した。
	・VectorSlice(), VectorDup() を実装した。
	・vector 型の PVal::len が常に [ 0, 1, 0, 0, 0 ] になるようにした。
	
2011.07.18 (Mon)
	・var_multi を元に、作成開始。
	・基盤完成。
	・参照同値性の比較に対応した。
	・加法(+)による連結(chain)に対応した。
	・vector 関数で即値風のオブジェクト生成できるようにした。
	・vector の実体を std::vector ではなく PVal** (動的配列<PVal*>) にした。
	・要素順序操作系コマンド (move, reverse, 他) を追加した。
	
// uedai 2011 - 2012.