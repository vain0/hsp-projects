#include "../crouton.as"

// vector の演算と内部変数

	v = vector(1, 2, 3)
	
// 代入(=)
// vector 型の値を代入すると、vector 型の新しい値が作られる。
// それは、代入された vector と「同じ変数」を「同じ順番」で持つ。

	u = v
	repeat 3
		mes strf("u(%d) = %s : v(%d) = %s", cnt, str(u(cnt)), cnt, str(v(cnt)))
	loop
	mes
	
// 「同じ変数を持つ」という言葉の意味
// この例では u(0) と v(0) は「同じ内部変数」を指している。
// そのため、その変数を書き換えると、u(0) と v(0) の値が同時に書き換わったように見える。

	v(0) = "「v(0) を書き換えた！」"
	mes "u(0) = " + u(0)
	mes
	
// 「新しい値」という言葉の意味
// この例では u, v はそれぞれ異なる vector なので、
// 片方を変更しても他方は変化しない。

	// u を長くする
	u(5) = "「u を長さ 6 にした。」"
	v(6) = 0
	
	// v は長くなってない (実行するとエラー)
	mes "v(5) = " + v(5)
	mes 
	
// 加算(+)
// vector 型を足すと、その2つの vector が持つ変数の列をつなげた vector が得られる。
// これも、元の vector と「同じ変数」を持つ。

	w = u + v
	// w = vector(u(0), u(1), ..., u(5), v(0), ..., v(2))
	repeat 9
		mes strf("w(%d) = %s", cnt, str(w(cnt)))
	loop
	mes
	
// 復習として、w が u や v の内部変数を持っていることを確認する。
// 「w(5) = u(5) (u の最後の要素)」なので、
// 「w(6) = v(0)」であることに注意する。

	w(1) = "「w(1) の値」"
	mes "u(1) = " + u(1)
	
	w(8) = "「w(8) の値」"
	mes "v(2) = " + v(2)

	mes "以上"
	wait 500
	

// 余談
// 内部変数は参照カウンタ方式でガベージコレクトされる。
// この例では、u が持っていた vector 型の値が消滅しても、
// w が持っている内部変数は死亡しない。
	dim u	// u が持っていた vector 型の値が消滅する
	mes "w(0) = " + w(0)

// また、終了時に w が持っている内部変数が解放されるが、
// スクリプトからそれを確認するのはめんどくさいのでサンプルは省く。

// 命令：vectorCopy vec1, vec2
// vec1 = vec2 と同じ意味。

// 命令：vectorChain vec1, vec2
// vec1 += vec2 と同じ意味。
	
	mes "余談終"
	stop
