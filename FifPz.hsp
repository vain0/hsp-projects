// FifPz

#packopt name "FifPz"
#packopt hide 1
#packopt orgpath 1

#include "Mo/CreateChildWindow.as"

goto *main

#include "FifPz.as"
#include "Sub_Control.hsp"
#include "Sub_Function.hsp"

//##############################################################################
//        メインルーチン
//##############################################################################
*main
	gosub *LInitialize
	goto  *mainlp
	
//*--------------------------------------------------------*
//        メインループ
//*--------------------------------------------------------*
*mainlp
	if ( bPlaying ) {
		gosub *LCheckKeyEvent		// キーイベント
	}
	await 64
	goto *mainlp
	
//##############################################################################
//        サブルーチン群
//##############################################################################

//*--------------------------------------------------------*
//        初期化サブルーチン
//*--------------------------------------------------------*
*LInitialize
	randomize
	gsel 0, -1
	
	gosub *LClearVariable
	gosub *LSetWindow
	gosub *LSetInterrupt
	
	gsel IDW_MAIN,   1
	gsel IDW_PUZZLE, 1
	return
	
// 変数を初期状態にセットする
*LClearVariable
	sdim filepath, MAX_PATH
	dim  sizePicFull,  2
	dim  sizePicShard, 2
	dim  placePics
	
	bPlaying      = false			// ゲーム中か
	id_cntShards  = 2				// 断片数コンボボックスの番号
	cntShardsRoot = 4				// 断片数のルート
	cntShards     = cntShardsRoot * cntShardsRoot
	idxDisShard   = cntShards - 1	// 無効断片の位置
	dirExchange   = -1				// 無効断片の移動する方向
	crefDisShard  = RGB(16, 16, 32)	// 無効断片の色
	
	// 局所的なもの
	dim infCombox_ShardsNumber, 2
	
	return
	
// ウィンドウを初期状態にセットする
*LSetWindow
	screen IDW_MAIN, ginfo(20) * 2, ginfo(21) * 2, 2, (ginfo(20) - 360) / 2, (ginfo(21) - 300) / 2, 360, 300
	title "FifPz"
		syscolor 15 : boxf , , , 30
		
		objsize 70, 20
		pos  10, 5 : button gosub "開く",   *OnBtn_OpenPicfile
		pos  90, 5 : button gosub "再配置", *OnBtn_ReplaceShards
		objsize 60, 20
		pos 170, 5 : combox id_cntShards, 120, "2×2\n3×3\n4×4\n5×5\n6×6\n7×7\n8×8"
		           : infCombox_ShardsNumber = objinfo(stat, 2), stat
		objsize 30, 20
		pos 240, 5 : button gosub "色", *OnBtn_ChangeColorOfDisShard
		
		CreateChildWindow hwnd, IDW_PUZZLE, ginfo(20) * 2, ginfo(21) * 2, 2 + 32
		width 360, 270, 0, 30
		
	buffer IDW_PICFULL, 0, 0
	
	return
	
// 割り込みを設定する
*LSetInterrupt
	gsel IDW_MAIN
		oncmd gosub *OnCommand, 0x0111
	return
	
//*--------------------------------------------------------*
//        画像の設定・初期化
//*--------------------------------------------------------*

// 画像ファイルを開く
*OnBtn_OpenPicfile
	dialog "jpg;*.bmp;*.gif", 16, "画像ファイル"
	if ( stat == 0 ) { return }
	filepath = refstr
	bPlaying = true
	
	// 画像を読み込む
	gsel IDW_PICFULL
	picload filepath
	sizePicFull  = ginfo(12), ginfo(13)
	
	// 断片の処理
	gosub *LResetPic
	
	return
	
// 画像を再設定する
*LResetPic
	gsel IDW_PICFULL
	sizePicShard.x = sizePicFull.x / cntShardsRoot	// 断片1つあたりの x サイズ
	sizePicShard.y = sizePicFull.y / cntShardsRoot	// 〃 y サイズ
	
	// 断片ごとに切り取る
	repeat cntShards
		buffer    IDW_PICSHARD_TOP + cnt, sizePicShard.x, sizePicShard.y
		copyShard IDW_PICFULL, cnt
	loop
	
	gosub *LReplaceShards	// 断片を再配置する
	gosub *LResetWindowSize	// ウィンドウをパズルの大きさに合わせる
	gosub *LRedrawPuzzle	// パズル部分を再描画する
	
	return
	
// 再配置コマンド
*OnBtn_ReplaceShards
	if ( bPlaying == false ) { return }
	gosub *LReplaceShards
	gosub *LRedrawPuzzle
	return
	
// 正解の配置
*LPlaceAnswerShards
	repeat cntShards - 1
		placePics(cnt) = cnt
	loop
	
	idxDisShard = cntShards - 1
	placePics(idxDisShard) = -1	// 無効断片の設定
	
	return
	
// ランダム再配置
*LReplaceShards
	dim placePics, cntShards
	
	// 昇順の配列を作成する
	gosub *LPlaceAnswerShards
	
	// 無効断片を適当に移動させる
	repeat 4
		repeat cntShards
			moveDisShard rnd(DIR_MAX)
		loop
	loop
	
	return
	
//*--------------------------------------------------------*
//        インターフェース部分
//*--------------------------------------------------------*
// パズル部分の再描画
*LRedrawPuzzle
	gsel IDW_PUZZLE
	redraw 2
	
	color32 crefDisShard : boxf
	
	// パズル部分に断片をコピー ( 順番は placePics 参照 )
	repeat cntShards
		if ( placePics(cnt) < 0 ) { continue }
		pos posidToPos(cnt, x), posidToPos(cnt, y)
		copyShard IDW_PICSHARD_TOP + placePics(cnt)
	loop
	
	redraw 1
	return
	
// ウィンドウを画像の大きさに合わせる
*LResetWindowSize
	gsel IDW_MAIN   : width sizePicFull.x, sizePicFull.y + 30
	gsel IDW_PUZZLE : width sizePicFull.x, sizePicFull.y, 0, 30
	return
	
// 無効断片の色を変える
*OnBtn_ChangeColorOfDisShard
	dialog "", 33
	if ( stat == 0 ) { return }
	crefDisShard = RGB(ginfo_r, ginfo_g, ginfo_b)
	
	// 無効断片を塗り潰し直す
	if ( bPlaying ) {
		gsel IDW_PUZZLE
		color32 crefDisShard
		px = posidToPos(idxDisShard, x)
		py = posidToPos(idxDisShard, y)
		boxf px, py, px + sizePicShard.x, py + sizePicShard.y
	}
	return
	
// キーイベントを調べる
*LCheckKeyEvent
	
	stick keydown
	if ( keydown == 0 ) {
		return
	} else : if ( keydown & 1 ) { dirExchange = DIR_LEFT
	} else : if ( keydown & 2 ) { dirExchange = DIR_UPPER
	} else : if ( keydown & 4 ) { dirExchange = DIR_RIGHT
	} else : if ( keydown & 8 ) { dirExchange = DIR_LOWER }
	
	// 無効断片の周り4つを動かすように見せるため、キーと反対方向に無効断片を動かす
	if ( dirExchange >= 0 ) {
		dirExchange = ( dirExchange + DIR_MAX / 2 ) \ DIR_MAX
		
		moveDisShard dirExchange
		gosub *LRedrawPuzzle
		dirExchange = -1
	}
	
	return
	
//##############################################################################
//        ウィンドウメッセージ・ハンドラ
//##############################################################################

// WM_COMMAND
*OnCommand
	switch ( lparam )
		// 断片数のコンボボックス
		case infCombox_ShardsNumber
			if ( HIWORD(wparam) == 1 ) {		// CBN_SELCHANGE (選択項目が変化した)
				sendmsg lparam, 0x0147, 0, 0	// CB_GETCURSEL (選択項目のインデックス)
				cntShardsRoot = stat + 2
				cntShards     = cntShardsRoot * cntShardsRoot
				
				if ( bPlaying ) {
					gosub *LResetPic
				}
				
				gsel IDW_MAIN : objsel 1
			}
			swbreak
			
	swend
	return
	