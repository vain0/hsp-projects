# Gitのコミット

さて、今回から **第2部** です。Gitの底力はまだまだこんなもんじゃないですからね！

## コミットオブジェクト
これまで直接は説明しませんでしたが、git commit を行うと、「前回の git commit より後にした変更」がリポジトリに記録されます。
このときの「記録」のことを、まとめて1個の **コミットオブジェクト**(commit object) と呼びます。
(単にコミットと略すのが一般的です。)

コミットオブジェクトには、以下のような情報が記録されています。

* コミットメッセージ
* コミットした人のユーザ名とメアド
* 変更後のファイル
* 親コミットオブジェクトたちのハッシュ値
* (他にもありますが、省略)

上3つはみなさんもご存知でしょう。
気になるのは「親コミットオブジェクト」ですね。

コミットオブジェクトの間には親子関係があります。
[第5回 Gitの記録](chapter5.md) で使った git log の結果を引用して説明します。

```
$ git log --oneline
3456001 7 回目の更新  [= HEAD]
  ↓
1720f58 6 回目の更新
  ↓
99bd126 5 回目の更新
  ↓
96a691b 4 回目の更新
  ↓
3a7f2d9 3 回目の更新
  ↓
70e529a 2 回目の更新
  ↓
dfb29ca 1 回目の更新  [親なしコミット]
```

ここでの矢印は、「子 → 親」という関係を表しています。
git log は、最新のコミットオブジェクト 3456001 (= HEAD) から始めて、親へ親へと辿っていくことで、コミットオブジェクト (のハッシュ値とメッセージ) を列挙していたのです。

そう考えると、コミットオブジェクトというのは、「1回の変更」と言いましたが、 **1つのバージョンを表している** とみなすことも可能です。

## HEADの定義の更新
さて、 [第5回](chapter5.md) で HEAD を以下のように説明しましたが、(意図的な)誤りです。謝ります。

> HEAD とは「最後に git commit された変更」を表しているものです。

いままで私が説明したコマンドだけを使っているかぎり、上の理解でもある意味正しいのですが、これから次のステップに進むため、もう少し正確な説明を与えます。

* HEAD とは、作業ディレクトリが元にしているコミットオブジェクトを指し示す名前である。

よく分かりませんね。
関係代名詞があるので、とりあえず2つの文に分けてみます。

* HEAD とは、あるコミットオブジェクトを指し示す名前である。
* 作業ディレクトリは、そのコミットオブジェクトを元にしている。

コミットオブジェクトは「バージョン」を表していると前節でいいましたが、ここで、そのように言い換えてみましょう。
「コミットオブジェクト」→「バージョン」と書き換えます。

* HEAD とは、あるバージョンを指し示す名前である。
* 作業ディレクトリは、そのバージョンを元にしている。

なんだか分かりやすくなってきた気がしてきました。
あとは「作業ディレクトリが、あるバージョンを元にしている」という文の意味が分かれば攻略できそうです。

一応再確認ですが、作業ディレクトリは、git の管理下に置かれているディレクトリのことでしたね。.git の外側。
作業ディレクトリの現在の状態、すなわち作業ディレクトリ内のファイルに変更があるかどうかは、git status や git diff で確認できるのでした。
ここで気にしてほしいのは、「変更がある」というのは「何かと比較して、変更がある」ということです。
いままで、git status や git diff は、作業ディレクトリ内にあるファイルを、 **何と** 比較していたのでしょうか？
その答えが「元にしているバージョン」、すなわち HEAD です。

git status や git diff は、作業ディレクトリにあるファイルを、バージョン HEAD に記録されたファイルと比較していたのです。

> HEAD とは、作業ディレクトリが元にしているコミットオブジェクトを指し示す名前である。

このことが分かると、git add && git commit が何をするのかも、より詳しく説明できるようになります。

0. 作業ディレクトリはクリーンな状態。(すなわち、バージョン HEAD に記録されたのと同じ状態にある。)
0. 作業ディレクトリに変更を加える。
0. git add と git commit を行う。
  0. HEAD を **親** とする新しいコミットオブジェクトが作られる。
  0. HEAD が新しいコミットオブジェクトの名前に更新される。

確認のため、各種コマンドを実行するたびに、HEAD がどうなるかみてみましょう。

0. 作業ディレクトリを作る。
0. git init する。
  * HEAD はまだ存在しない。
  * このときのリポジトリにはコミットオブジェクトが存在しないので、「コミットオブジェクトの名前」であるところの HEAD も当然ない。
0. ファイルを作成する。
  * 同じく HEAD はありません。
0. git add と git commit を行う。
  * 新しいコミットオブジェクトが作成される。
  * いま HEAD は存在していなかったので、そのコミットオブジェクトの「親」も存在しない。
  * そして、この新しいオブジェクトの名前として、HEAD が生まれる。
0. ファイルが変更される。
0. git add と git commit を行う。
  * 新しいコミットオブジェクトが作成される。
  * その親は、現在の HEAD である「最初のコミットオブジェクト」。
  * そして、HEAD はこの新しいオブジェクトの名前になる。

このように、前回までに説明したような、「ファイルの変更と git add && git commit を繰り返していく」ような使いかたをするぶんには、HEAD はいつも「最新のコミットオブジェクトの名前」になるんですね。

では HEAD が「最新のコミットオブジェクトの名前」ではなくなるのは、いつか？
[次回](chapter09.md) に続きます。

## 参考文献
* [もうGitは怖くない： 自信を持って使いたいあなたへ - 檜山正幸のキマイラ飼育記](http://d.hatena.ne.jp/m-hiyama/20150928/1443397382) (2016年3月18日閲覧)
  * コミットグラフに関する、日本語で読めるかなり詳しい解説。
